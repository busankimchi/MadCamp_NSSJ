import _typeof from "@babel/runtime/helpers/esm/typeof";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _findIndex from "lodash/findIndex";
import _isNil from "lodash/isNil";
import _isNumber from "lodash/isNumber";
import _invoke from "lodash/invoke";
import _isFunction from "lodash/isFunction";
import _map from "lodash/map";
import _differenceBy from "lodash/differenceBy";
import _isArray from "lodash/isArray";
import _uniqueId from "lodash/uniqueId";
import { handleRef, Ref } from '@stardust-ui/react-component-ref';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import cx from 'classnames';
import * as keyboardKey from 'keyboard-key';
import { withSafeTypeForAs } from '../../types';
import Downshift from 'downshift';
import { AutoControlledComponent, commonPropTypes, isFromKeyboard } from '../../lib';
import List from '../List/List';
import DropdownItem from './DropdownItem';
import DropdownSelectedItem from './DropdownSelectedItem';
import DropdownSearchInput from './DropdownSearchInput';
import Button from '../Button/Button';
import { screenReaderContainerStyles } from '../../lib/accessibility/Styles/accessibilityStyles';
import ListItem from '../List/ListItem';
import Icon from '../Icon/Icon';
import Portal from '../Portal/Portal';
import { ALIGNMENTS, POSITIONS, Popper } from '../../lib/positioner';

var Dropdown =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Dropdown, _AutoControlledCompon);

  function Dropdown() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Dropdown);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Dropdown)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "buttonRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "inputRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "listRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "selectedItemsRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "containerRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "a11yStatusTimeout", void 0);

    _defineProperty(_assertThisInitialized(_this), "charKeysPressedTimeout", void 0);

    _defineProperty(_assertThisInitialized(_this), "defaultTriggerButtonId", _uniqueId('dropdown-trigger-button-'));

    _defineProperty(_assertThisInitialized(_this), "handleSearchQueryChange", function (searchQuery) {
      _this.setStateAndInvokeHandler('onSearchQueryChange', null, {
        searchQuery: searchQuery,
        highlightedIndex: _this.props.highlightFirstItemOnOpen ? 0 : null,
        open: searchQuery === '' ? false : _this.state.open
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleDownshiftStateChanges", function (state, changes) {
      var activeElement = _this.context.target.activeElement;

      switch (changes.type) {
        case Downshift.stateChangeTypes.blurButton:
          // Downshift closes the list by default on trigger blur. It does not support the case when dropdown is
          // single selection and focuses list on trigger click/up/down/space/enter. Treating that here.
          if (state.isOpen && activeElement === _this.listRef.current) {
            return {}; // won't change state in this case.
          }

        default:
          return changes;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleStateChange", function (changes) {
      if (changes.isOpen !== undefined && changes.isOpen !== _this.state.open) {
        var newState = {
          open: changes.isOpen,
          highlightedIndex: _this.state.highlightedIndex
        };

        if (changes.isOpen) {
          var highlightedIndexOnArrowKeyOpen = _this.getHighlightedIndexOnArrowKeyOpen(changes);

          if (_isNumber(highlightedIndexOnArrowKeyOpen)) {
            newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
          }

          if (!_this.props.search) {
            _this.listRef.current.focus();
          }
        } else {
          newState.highlightedIndex = null;
        }

        _this.setStateAndInvokeHandler('onOpenChange', null, newState);
      }

      if (_this.state.open && _isNumber(changes.highlightedIndex)) {
        var itemIsFromKeyboard = changes.type !== Downshift.stateChangeTypes.itemMouseEnter;

        _this.setState({
          itemIsFromKeyboard: itemIsFromKeyboard,
          highlightedIndex: changes.highlightedIndex
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "isSelectedItemActive", function (index) {
      return index === _this.state.activeSelectedIndex;
    });

    _defineProperty(_assertThisInitialized(_this), "handleItemOverrides", function (item, index, getItemProps, selected) {
      return function (predefinedProps) {
        return {
          accessibilityItemProps: Object.assign({}, getItemProps({
            item: item,
            index: index,
            onClick: function onClick(e) {
              e.stopPropagation();
              e.nativeEvent.stopImmediatePropagation();

              _invoke(predefinedProps, 'onClick', e, predefinedProps);
            }
          }), !_this.props.multiple && {
            'aria-selected': selected
          })
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleSelectedItemOverrides", function (item, rtl) {
      return function (predefinedProps) {
        return {
          onRemove: function onRemove(e, dropdownSelectedItemProps) {
            _this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
          },
          onClick: function onClick(e, dropdownSelectedItemProps) {
            _this.setState({
              activeSelectedIndex: _this.state.value.indexOf(item)
            });

            e.stopPropagation();

            _invoke(predefinedProps, 'onClick', e, dropdownSelectedItemProps);
          },
          onKeyDown: function onKeyDown(e, dropdownSelectedItemProps) {
            _this.handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps, rtl);
          }
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleSearchInputOverrides", function (highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps) {
      return function (predefinedProps) {
        var handleInputBlur = function handleInputBlur(e, searchInputProps) {
          _this.setState({
            focused: false,
            isFromKeyboard: isFromKeyboard()
          });

          e.nativeEvent['preventDownshiftDefault'] = true;

          _invoke(predefinedProps, 'onInputBlur', e, searchInputProps);
        };

        var handleInputKeyDown = function handleInputKeyDown(e, searchInputProps) {
          switch (keyboardKey.getCode(e)) {
            case keyboardKey.Tab:
              _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);

              break;

            case keyboardKey.ArrowLeft:
              if (!rtl) {
                _this.trySetLastSelectedItemAsActive();
              }

              break;

            case keyboardKey.ArrowRight:
              if (rtl) {
                _this.trySetLastSelectedItemAsActive();
              }

              break;

            case keyboardKey.Backspace:
              _this.tryRemoveItemFromValue();

              break;

            default:
              break;
          }

          _invoke(predefinedProps, 'onInputKeyDown', e, Object.assign({}, searchInputProps, {
            highlightedIndex: highlightedIndex,
            selectItemAtIndex: selectItemAtIndex
          }));
        };

        return {
          // getInputProps adds Downshift handlers. We also add our own by passing them as params to that function.
          // user handlers were also added to our handlers previously, at the beginning of this function.
          accessibilityInputProps: Object.assign({}, getInputProps({
            onBlur: function onBlur(e) {
              handleInputBlur(e, predefinedProps);
            },
            onKeyDown: function onKeyDown(e) {
              handleInputKeyDown(e, predefinedProps);
            }
          })),
          // same story as above for getRootProps.
          accessibilityComboboxProps: accessibilityComboboxProps,
          onFocus: function onFocus(e, searchInputProps) {
            _this.setState({
              focused: true,
              isFromKeyboard: isFromKeyboard()
            });

            _invoke(predefinedProps, 'onFocus', e, searchInputProps);
          },
          onInputBlur: function onInputBlur(e, searchInputProps) {
            handleInputBlur(e, searchInputProps);
          },
          onInputKeyDown: function onInputKeyDown(e, searchInputProps) {
            handleInputKeyDown(e, searchInputProps);
          }
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleTabSelection", function (e, highlightedIndex, selectItemAtIndex, toggleMenu) {
      if (_this.state.open) {
        if (!_isNil(highlightedIndex) && _this.state.filteredItems.length) {
          selectItemAtIndex(highlightedIndex);

          if (!_this.props.moveFocusOnTab && _this.props.multiple) {
            e.preventDefault();
          }
        } else {
          toggleMenu();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "trySetLastSelectedItemAsActive", function () {
      var multiple = _this.props.multiple;
      var value = _this.state.value;

      if (!multiple || _this.inputRef.current && _this.inputRef.current.selectionStart !== 0) {
        return;
      }

      if (value.length > 0) {
        // If last element was already active, perform a 'reset' of activeSelectedIndex.
        if (_this.state.activeSelectedIndex === value.length - 1) {
          _this.setState({
            activeSelectedIndex: null
          }, function () {
            _this.setState({
              activeSelectedIndex: value.length - 1
            });
          });
        } else {
          _this.setState({
            activeSelectedIndex: value.length - 1
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "tryRemoveItemFromValue", function () {
      var multiple = _this.props.multiple;
      var _this$state = _this.state,
          searchQuery = _this$state.searchQuery,
          value = _this$state.value;

      if (multiple && (searchQuery === '' || _this.inputRef.current.selectionStart === 0) && value.length > 0) {
        _this.removeItemFromValue();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleClear", function (e) {
      var _this$getInitialAutoC = _this.getInitialAutoControlledState(_this.props),
          activeSelectedIndex = _this$getInitialAutoC.activeSelectedIndex,
          highlightedIndex = _this$getInitialAutoC.highlightedIndex,
          open = _this$getInitialAutoC.open,
          searchQuery = _this$getInitialAutoC.searchQuery,
          value = _this$getInitialAutoC.value;

      _this.setStateAndInvokeHandler('onSelectedChange', e, {
        activeSelectedIndex: activeSelectedIndex,
        highlightedIndex: highlightedIndex,
        open: open,
        searchQuery: searchQuery,
        value: value
      });

      _this.setState({
        activeSelectedIndex: activeSelectedIndex,
        highlightedIndex: highlightedIndex,
        open: open,
        searchQuery: searchQuery,
        value: value
      });

      _this.tryFocusSearchInput();

      _this.tryFocusTriggerButton();
    });

    _defineProperty(_assertThisInitialized(_this), "handleContainerClick", function () {
      _this.tryFocusSearchInput();
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonKeyDown", function (e, rtl) {
      switch (keyboardKey.getCode(e)) {
        case keyboardKey.ArrowLeft:
          if (!rtl) {
            _this.trySetLastSelectedItemAsActive();
          }

          return;

        case keyboardKey.ArrowRight:
          if (rtl) {
            _this.trySetLastSelectedItemAsActive();
          }

          return;

        default:
          return;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleListKeyDown", function (e, highlightedIndex, accessibilityInputPropsKeyDown, toggleMenu, selectItemAtIndex) {
      var keyCode = keyboardKey.getCode(e);

      switch (keyCode) {
        case keyboardKey.Tab:
          _this.handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);

          return;

        case keyboardKey.Escape:
          accessibilityInputPropsKeyDown(e);

          _this.tryFocusTriggerButton();

          e.stopPropagation();
          return;

        default:
          var keyString = String.fromCharCode(keyCode);

          if (/[a-zA-Z0-9]/.test(keyString)) {
            _this.setHighlightedIndexOnCharKeyDown(keyString);
          }

          accessibilityInputPropsKeyDown(e);
          return;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleSelectedChange", function (item) {
      var _this$props = _this.props,
          items = _this$props.items,
          multiple = _this$props.multiple,
          getA11ySelectionMessage = _this$props.getA11ySelectionMessage;
      var value = _this.state.value;

      _this.setStateAndInvokeHandler('onSelectedChange', null, {
        searchQuery: _this.getSelectedItemAsString(item),
        value: multiple ? [].concat(_toConsumableArray(value), [item]) : [item]
      });

      if (!multiple) {
        _this.setState({
          highlightedIndex: items.indexOf(item)
        });
      }

      if (getA11ySelectionMessage && getA11ySelectionMessage.onAdd) {
        _this.setA11ySelectionMessage(getA11ySelectionMessage.onAdd(item));
      }

      if (multiple) {
        setTimeout(function () {
          return _this.selectedItemsRef.current.scrollTop = _this.selectedItemsRef.current.scrollHeight;
        }, 0);
      }

      _this.tryFocusTriggerButton();
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonOrListFocus", function () {
      _this.setState({
        focused: true,
        isFromKeyboard: isFromKeyboard()
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleTriggerButtonBlur", function (e) {
      if (_this.listRef.current !== e.relatedTarget) {
        _this.setState({
          focused: false,
          isFromKeyboard: isFromKeyboard()
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleListBlur", function (e) {
      if (_this.buttonRef.current !== e.relatedTarget) {
        _this.setState({
          focused: false,
          isFromKeyboard: isFromKeyboard()
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setHighlightedIndexOnCharKeyDown", function (keyString) {
      var _this$state2 = _this.state,
          highlightedIndex = _this$state2.highlightedIndex,
          filteredItemStrings = _this$state2.filteredItemStrings,
          startingString = _this$state2.startingString;
      var newStartingString = "".concat(startingString).concat(keyString.toLowerCase());
      var newHighlightedIndex = -1;

      _this.setStartingString(newStartingString);

      if (_isNumber(highlightedIndex)) {
        newHighlightedIndex = _findIndex(filteredItemStrings, function (item) {
          return item.startsWith(newStartingString);
        }, highlightedIndex + (startingString.length > 0 ? 0 : 1));
      }

      if (newHighlightedIndex < 0) {
        newHighlightedIndex = _findIndex(filteredItemStrings, function (item) {
          return item.startsWith(newStartingString);
        });
      }

      if (newHighlightedIndex >= 0) {
        _this.setState({
          highlightedIndex: newHighlightedIndex
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "setStateAndInvokeHandler", function (handlerName, event, newState) {
      var proposedValue = _isNil(newState.value) ? _this.state.value : newState.value; // `proposedValue` should be normalized for single/multiple variations, `null` condition is
      // required as first item can be undefined

      var newValue = _this.props.multiple ? proposedValue : proposedValue[0] || null;

      _this.setState(newState);

      _invoke(_this.props, handlerName, event, Object.assign({}, _this.props, newState, {
        value: newValue
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "tryFocusTriggerButton", function () {
      if (!_this.props.search) {
        _this.buttonRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "tryFocusSearchInput", function () {
      if (_this.props.search) {
        _this.inputRef.current.focus();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getSelectedItemAsString", function (value) {
      var _this$props2 = _this.props,
          itemToString = _this$props2.itemToString,
          multiple = _this$props2.multiple,
          placeholder = _this$props2.placeholder;

      if (!value) {
        return placeholder;
      }

      if (multiple) {
        return '';
      }

      return itemToString(value);
    });

    _defineProperty(_assertThisInitialized(_this), "getHighlightedIndexOnArrowKeyOpen", function (changes) {
      var _this$state3 = _this.state,
          filteredItems = _this$state3.filteredItems,
          highlightedIndex = _this$state3.highlightedIndex,
          value = _this$state3.value;
      var _this$props3 = _this.props,
          highlightFirstItemOnOpen = _this$props3.highlightFirstItemOnOpen,
          items = _this$props3.items,
          multiple = _this$props3.multiple,
          search = _this$props3.search;
      var isArrowUp = changes.type === Downshift.stateChangeTypes.keyDownArrowUp;
      var isArrowDown = changes.type === Downshift.stateChangeTypes.keyDownArrowDown;
      var itemsLength = filteredItems.length;

      if (highlightedIndex) {
        return highlightedIndex;
      }

      if (highlightFirstItemOnOpen) {
        // otherwise, if highlightFirstItemOnOpen prop is provied, highlight first item.
        return 0;
      }

      if (!multiple && !search && value.length > 0) {
        // in single selection, if there is a selected item, highlight it.
        var offset = isArrowUp ? -1 : isArrowDown ? 1 : 0;
        var newHighlightedIndex = items.indexOf(value[0]) + offset;

        if (newHighlightedIndex >= itemsLength) {
          return 0;
        }

        if (newHighlightedIndex < 0) {
          return itemsLength - 1;
        }

        return newHighlightedIndex;
      }

      if (isArrowDown) {
        return 0;
      }

      if (isArrowUp) {
        return itemsLength - 1;
      }

      return null;
    });

    _defineProperty(_assertThisInitialized(_this), "setA11ySelectionMessage", function (a11ySelectionStatus) {
      clearTimeout(_this.a11yStatusTimeout);

      _this.setState({
        a11ySelectionStatus: a11ySelectionStatus
      });

      _this.a11yStatusTimeout = setTimeout(function () {
        _this.setState({
          a11ySelectionStatus: ''
        });
      }, Dropdown.a11yStatusCleanupTime);
    });

    _defineProperty(_assertThisInitialized(_this), "setStartingString", function (startingString) {
      clearTimeout(_this.charKeysPressedTimeout);

      _this.setState({
        startingString: startingString
      });

      _this.charKeysPressedTimeout = setTimeout(function () {
        _this.setState({
          startingString: ''
        });
      }, Dropdown.charKeyPressedCleanupTime);
    });

    return _this;
  }

  _createClass(Dropdown, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState(_ref) {
      var multiple = _ref.multiple,
          search = _ref.search;
      return {
        a11ySelectionStatus: '',
        activeSelectedIndex: multiple ? null : undefined,
        filteredItems: undefined,
        filteredItemStrings: undefined,
        focused: false,
        startingString: search ? undefined : '',
        open: false,
        highlightedIndex: this.props.highlightFirstItemOnOpen ? 0 : null,
        searchQuery: search ? '' : undefined,
        value: [],
        itemIsFromKeyboard: false,
        isFromKeyboard: false
      };
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.a11yStatusTimeout);
      clearTimeout(this.charKeysPressedTimeout);
    }
    /**
     * Used to compute the filtered items (by value and search query) and, if needed,
     * their string equivalents, in order to be used throughout the component.
     */

  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var _this2 = this;

      var ElementType = _ref2.ElementType,
          classes = _ref2.classes,
          styles = _ref2.styles,
          variables = _ref2.variables,
          unhandledProps = _ref2.unhandledProps,
          rtl = _ref2.rtl;
      var _this$props4 = this.props,
          clearable = _this$props4.clearable,
          clearIndicator = _this$props4.clearIndicator,
          search = _this$props4.search,
          multiple = _this$props4.multiple,
          getA11yStatusMessage = _this$props4.getA11yStatusMessage,
          itemToString = _this$props4.itemToString,
          toggleIndicator = _this$props4.toggleIndicator;
      var _this$state4 = this.state,
          highlightedIndex = _this$state4.highlightedIndex,
          open = _this$state4.open,
          searchQuery = _this$state4.searchQuery,
          value = _this$state4.value;
      return React.createElement(ElementType, _extends({
        className: classes.root
      }, unhandledProps), React.createElement(Downshift, {
        isOpen: open,
        onChange: this.handleSelectedChange,
        onInputValueChange: this.handleSearchQueryChange,
        inputValue: search ? searchQuery : null,
        stateReducer: this.handleDownshiftStateChanges,
        itemToString: itemToString,
        selectedItem: null,
        getA11yStatusMessage: getA11yStatusMessage,
        highlightedIndex: highlightedIndex,
        onStateChange: this.handleStateChange,
        labelId: this.props['aria-labelledby'],
        environment: this.context.target.defaultView,
        inputId: this.props.searchInput && this.props.searchInput['id'] ? this.props.searchInput['id'] : undefined
      }, function (_ref3) {
        var getInputProps = _ref3.getInputProps,
            getItemProps = _ref3.getItemProps,
            getMenuProps = _ref3.getMenuProps,
            getRootProps = _ref3.getRootProps,
            getToggleButtonProps = _ref3.getToggleButtonProps,
            toggleMenu = _ref3.toggleMenu,
            highlightedIndex = _ref3.highlightedIndex,
            selectItemAtIndex = _ref3.selectItemAtIndex;

        var _getRootProps = getRootProps({
          refKey: 'innerRef'
        }, {
          suppressRefError: true
        }),
            innerRef = _getRootProps.innerRef,
            accessibilityRootPropsRest = _objectWithoutProperties(_getRootProps, ["innerRef"]);

        var showClearIndicator = clearable && value.length > 0;
        return React.createElement(Ref, {
          innerRef: innerRef
        }, React.createElement("div", {
          ref: _this2.containerRef,
          className: cx(Dropdown.slotClassNames.container, classes.container),
          onClick: search && !open ? _this2.handleContainerClick : undefined
        }, React.createElement("div", {
          ref: _this2.selectedItemsRef,
          className: cx(Dropdown.slotClassNames.selectedItems, classes.selectedItems)
        }, multiple && _this2.renderSelectedItems(variables, rtl), search ? _this2.renderSearchInput(accessibilityRootPropsRest, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) : _this2.renderTriggerButton(styles, rtl, getToggleButtonProps)), showClearIndicator ? Icon.create(clearIndicator, {
          defaultProps: function defaultProps() {
            return {
              className: Dropdown.slotClassNames.clearIndicator,
              styles: styles.clearIndicator,
              xSpacing: 'none'
            };
          },
          overrideProps: function overrideProps(predefinedProps) {
            return {
              onClick: function onClick(e, iconProps) {
                _invoke(predefinedProps, 'onClick', e, iconProps);

                _this2.handleClear(e);
              }
            };
          }
        }) : Icon.create(toggleIndicator, {
          defaultProps: function defaultProps() {
            return {
              className: Dropdown.slotClassNames.toggleIndicator,
              name: 'chevron-down',
              styles: styles.toggleIndicator,
              outline: true,
              size: 'small'
            };
          },
          overrideProps: function overrideProps(predefinedProps) {
            return {
              onClick: function onClick(e, indicatorProps) {
                _invoke(predefinedProps, 'onClick', e, indicatorProps);

                getToggleButtonProps().onClick(e);
              }
            };
          }
        }), _this2.renderItemsList(styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl)));
      }), React.createElement(Portal, {
        open: !!this.props.getA11ySelectionMessage
      }, React.createElement("div", {
        role: "status",
        "aria-live": "polite",
        "aria-relevant": "additions text",
        style: screenReaderContainerStyles
      }, this.state.a11ySelectionStatus)));
    }
  }, {
    key: "renderTriggerButton",
    value: function renderTriggerButton(styles, rtl, getToggleButtonProps) {
      var _this3 = this;

      var triggerButton = this.props.triggerButton;
      var value = this.state.value;
      var content = this.getSelectedItemAsString(value[0]);
      var triggerButtonId = triggerButton['id'] || this.defaultTriggerButtonId;
      var triggerButtonProps = getToggleButtonProps({
        onFocus: this.handleTriggerButtonOrListFocus,
        onBlur: this.handleTriggerButtonBlur,
        onKeyDown: function onKeyDown(e) {
          _this3.handleTriggerButtonKeyDown(e, rtl);
        },
        'aria-label': undefined,
        'aria-labelledby': [this.props['aria-labelledby'], triggerButtonId].filter(function (l) {
          return !!l;
        }).join(' ')
      });

      var _onClick = triggerButtonProps.onClick,
          _onFocus = triggerButtonProps.onFocus,
          _onBlur = triggerButtonProps.onBlur,
          _onKeyDown = triggerButtonProps.onKeyDown,
          restTriggerButtonProps = _objectWithoutProperties(triggerButtonProps, ["onClick", "onFocus", "onBlur", "onKeyDown"]);

      return React.createElement(Ref, {
        innerRef: this.buttonRef
      }, Button.create(triggerButton, {
        defaultProps: function defaultProps() {
          return Object.assign({
            className: Dropdown.slotClassNames.triggerButton,
            content: content,
            id: triggerButtonId,
            fluid: true,
            styles: styles.triggerButton
          }, restTriggerButtonProps);
        },
        overrideProps: function overrideProps(predefinedProps) {
          return {
            onClick: function onClick(e) {
              _onClick(e);

              _invoke(predefinedProps, 'onClick', e, predefinedProps);
            },
            onFocus: function onFocus(e) {
              _onFocus(e);

              _invoke(predefinedProps, 'onFocus', e, predefinedProps);
            },
            onBlur: function onBlur(e) {
              _onBlur(e);

              _invoke(predefinedProps, 'onBlur', e, predefinedProps);
            },
            onKeyDown: function onKeyDown(e) {
              _onKeyDown(e);

              _invoke(predefinedProps, 'onKeyDown', e, predefinedProps);
            }
          };
        }
      }));
    }
  }, {
    key: "renderSearchInput",
    value: function renderSearchInput(accessibilityComboboxProps, rtl, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) {
      var _this4 = this;

      var _this$props5 = this.props,
          inline = _this$props5.inline,
          searchInput = _this$props5.searchInput,
          multiple = _this$props5.multiple,
          placeholder = _this$props5.placeholder;
      var _this$state5 = this.state,
          searchQuery = _this$state5.searchQuery,
          value = _this$state5.value;
      var noPlaceholder = searchQuery.length > 0 || multiple && value.length > 0;
      return DropdownSearchInput.create(searchInput || {}, {
        defaultProps: function defaultProps() {
          return {
            className: Dropdown.slotClassNames.searchInput,
            placeholder: noPlaceholder ? '' : placeholder,
            inline: inline,
            variables: variables,
            inputRef: _this4.inputRef
          };
        },
        overrideProps: this.handleSearchInputOverrides(highlightedIndex, rtl, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps)
      });
    }
  }, {
    key: "renderItemsList",
    value: function renderItemsList(styles, variables, highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps, rtl) {
      var _this5 = this;

      var _this$props6 = this.props,
          align = _this$props6.align,
          offset = _this$props6.offset,
          position = _this$props6.position,
          search = _this$props6.search,
          unstable_pinned = _this$props6.unstable_pinned;
      var open = this.state.open;
      var items = open ? this.renderItems(styles, variables, getItemProps, highlightedIndex) : [];

      var _getMenuProps = getMenuProps({
        refKey: 'innerRef'
      }, {
        suppressRefError: true
      }),
          _innerRef = _getMenuProps.innerRef,
          accessibilityMenuProps = _objectWithoutProperties(_getMenuProps, ["innerRef"]); // If it's just a selection, some attributes and listeners from Downshift input need to go on the menu list.


      if (!search) {
        var accessibilityInputProps = getInputProps();
        accessibilityMenuProps['aria-activedescendant'] = accessibilityInputProps['aria-activedescendant'];

        accessibilityMenuProps['onKeyDown'] = function (e) {
          _this5.handleListKeyDown(e, highlightedIndex, accessibilityInputProps['onKeyDown'], toggleMenu, selectItemAtIndex);
        };
      }

      return React.createElement(Ref, {
        innerRef: function innerRef(listElement) {
          handleRef(_this5.listRef, listElement);
          handleRef(_innerRef, listElement);
        }
      }, React.createElement(Popper, {
        align: align,
        position: position,
        offset: offset,
        rtl: rtl,
        enabled: open,
        targetRef: this.containerRef,
        unstable_pinned: unstable_pinned,
        positioningDependencies: [items.length]
      }, React.createElement(List, _extends({
        className: Dropdown.slotClassNames.itemsList
      }, accessibilityMenuProps, {
        styles: styles.list,
        tabIndex: search ? undefined : -1 // needs to be focused when trigger button is activated.
        ,
        "aria-hidden": !open,
        onFocus: this.handleTriggerButtonOrListFocus,
        onBlur: this.handleListBlur,
        items: items
      }))));
    }
  }, {
    key: "renderItems",
    value: function renderItems(styles, variables, getItemProps, highlightedIndex) {
      var _this6 = this;

      var _this$props7 = this.props,
          loading = _this$props7.loading,
          loadingMessage = _this$props7.loadingMessage,
          noResultsMessage = _this$props7.noResultsMessage,
          renderItem = _this$props7.renderItem,
          checkable = _this$props7.checkable,
          checkableIndicator = _this$props7.checkableIndicator;
      var _this$state6 = this.state,
          filteredItems = _this$state6.filteredItems,
          value = _this$state6.value;

      var items = _map(filteredItems, function (item, index) {
        return function (render) {
          return render(item, function () {
            var selected = value.indexOf(item) !== -1;
            return DropdownItem.create(item, {
              defaultProps: function defaultProps() {
                return Object.assign({
                  className: Dropdown.slotClassNames.item,
                  active: highlightedIndex === index,
                  selected: selected,
                  checkable: checkable,
                  checkableIndicator: checkableIndicator,
                  isFromKeyboard: _this6.state.itemIsFromKeyboard,
                  variables: variables
                }, _typeof(item) === 'object' && !item.hasOwnProperty('key') && {
                  key: item.header
                });
              },
              overrideProps: _this6.handleItemOverrides(item, index, getItemProps, selected),
              render: renderItem
            });
          });
        };
      });

      return [].concat(_toConsumableArray(items), [loading && ListItem.create(loadingMessage, {
        defaultProps: function defaultProps() {
          return {
            key: 'loading-message',
            styles: styles.loadingMessage
          };
        }
      }), !loading && items.length === 0 && ListItem.create(noResultsMessage, {
        defaultProps: function defaultProps() {
          return {
            key: 'no-results-message',
            styles: styles.noResultsMessage
          };
        }
      })]);
    }
  }, {
    key: "renderSelectedItems",
    value: function renderSelectedItems(variables, rtl) {
      var _this7 = this;

      var renderSelectedItem = this.props.renderSelectedItem;
      var value = this.state.value;

      if (value.length === 0) {
        return null;
      }

      return value.map(function (item, index) {
        return (// (!) an item matches DropdownItemProps
          DropdownSelectedItem.create(item, {
            defaultProps: function defaultProps() {
              return Object.assign({
                className: Dropdown.slotClassNames.selectedItem,
                active: _this7.isSelectedItemActive(index),
                variables: variables
              }, _typeof(item) === 'object' && !item.hasOwnProperty('key') && {
                key: item.header
              });
            },
            overrideProps: _this7.handleSelectedItemOverrides(item, rtl),
            render: renderSelectedItem
          })
        );
      });
    }
  }, {
    key: "handleSelectedItemKeyDown",
    value: function handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps, rtl) {
      var _this$state7 = this.state,
          activeSelectedIndex = _this$state7.activeSelectedIndex,
          value = _this$state7.value;
      var previousKey = rtl ? keyboardKey.ArrowRight : keyboardKey.ArrowLeft;
      var nextKey = rtl ? keyboardKey.ArrowLeft : keyboardKey.ArrowRight;

      switch (keyboardKey.getCode(e)) {
        case keyboardKey.Delete:
        case keyboardKey.Backspace:
          this.handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
          break;

        case previousKey:
          if (value.length > 0 && !_isNil(activeSelectedIndex) && activeSelectedIndex > 0) {
            this.setState({
              activeSelectedIndex: activeSelectedIndex - 1
            });
          }

          break;

        case nextKey:
          if (value.length > 0 && !_isNil(activeSelectedIndex)) {
            if (activeSelectedIndex < value.length - 1) {
              this.setState({
                activeSelectedIndex: activeSelectedIndex + 1
              });
            } else {
              this.setState({
                activeSelectedIndex: null
              });

              if (this.props.search) {
                e.preventDefault(); // prevents caret to forward one position in input.

                this.inputRef.current.focus();
              } else {
                this.buttonRef.current.focus();
              }
            }
          }

          break;

        default:
          break;
      }

      _invoke(predefinedProps, 'onKeyDown', e, dropdownSelectedItemProps);
    }
  }, {
    key: "handleSelectedItemRemove",
    value: function handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps) {
      this.setState({
        activeSelectedIndex: null
      });
      this.removeItemFromValue(item);
      this.tryFocusSearchInput();
      this.tryFocusTriggerButton();

      _invoke(predefinedProps, 'onRemove', e, dropdownSelectedItemProps);
    }
  }, {
    key: "removeItemFromValue",
    value: function removeItemFromValue(item) {
      var getA11ySelectionMessage = this.props.getA11ySelectionMessage;
      var value = this.state.value;
      var poppedItem = item;

      if (poppedItem) {
        value = value.filter(function (currentElement) {
          return currentElement !== item;
        });
      } else {
        poppedItem = value.pop();
      }

      if (getA11ySelectionMessage && getA11ySelectionMessage.onRemove) {
        this.setA11ySelectionMessage(getA11ySelectionMessage.onRemove(poppedItem));
      }

      this.setStateAndInvokeHandler('onSelectedChange', null, {
        value: value
      });
    }
    /**
     * Calls setState and invokes event handler exposed to user.
     * We don't have the event object for most events coming from Downshift se we send an empty event
     * because we want to keep the event handling interface
     */

  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(props, state) {
      var items = props.items,
          itemToString = props.itemToString,
          itemToValue = props.itemToValue,
          multiple = props.multiple,
          search = props.search;
      var searchQuery = state.searchQuery,
          rawValue = state.value; // `normalizedValue` should be normilized always as it can be received from props

      var normalizedValue = _isArray(rawValue) ? rawValue : [rawValue];
      var value = multiple ? normalizedValue : normalizedValue.slice(0, 1);
      var filteredItemsByValue = multiple ? _differenceBy(items, value, itemToValue) : items;

      var filteredItemStrings = _map(filteredItemsByValue, function (filteredItem) {
        return itemToString(filteredItem).toLowerCase();
      });

      var modifiedState = {
        filteredItems: filteredItemsByValue,
        filteredItemStrings: filteredItemStrings,
        value: value
      };

      if (search) {
        if (_isFunction(search)) {
          modifiedState.filteredItems = search(filteredItemsByValue, searchQuery);
        } else {
          modifiedState.filteredItems = filteredItemsByValue.filter(function (item) {
            return itemToString(item).toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1;
          });
        }
      }

      return modifiedState;
    }
  }]);

  return Dropdown;
}(AutoControlledComponent);

_defineProperty(Dropdown, "displayName", 'Dropdown');

_defineProperty(Dropdown, "className", 'ui-dropdown');

_defineProperty(Dropdown, "a11yStatusCleanupTime", 500);

_defineProperty(Dropdown, "charKeyPressedCleanupTime", 500);

_defineProperty(Dropdown, "slotClassNames", void 0);

_defineProperty(Dropdown, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  accessibility: false,
  children: false,
  content: false
}), {
  activeSelectedIndex: PropTypes.number,
  align: PropTypes.oneOf(ALIGNMENTS),
  checkable: PropTypes.bool,
  checkableIndicator: customPropTypes.itemShorthandWithoutJSX,
  clearable: PropTypes.bool,
  clearIndicator: customPropTypes.itemShorthand,
  defaultActiveSelectedIndex: PropTypes.number,
  defaultOpen: PropTypes.bool,
  defaultHighlightedIndex: PropTypes.number,
  defaultSearchQuery: PropTypes.string,
  defaultValue: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  fluid: PropTypes.bool,
  getA11ySelectionMessage: PropTypes.object,
  getA11yStatusMessage: PropTypes.func,
  highlightFirstItemOnOpen: PropTypes.bool,
  highlightedIndex: PropTypes.number,
  inline: PropTypes.bool,
  items: customPropTypes.collectionShorthand,
  itemToString: PropTypes.func,
  itemToValue: PropTypes.func,
  loading: PropTypes.bool,
  loadingMessage: customPropTypes.itemShorthand,
  moveFocusOnTab: PropTypes.bool,
  multiple: PropTypes.bool,
  noResultsMessage: customPropTypes.itemShorthand,
  offset: PropTypes.string,
  onOpenChange: PropTypes.func,
  onSearchQueryChange: PropTypes.func,
  onSelectedChange: PropTypes.func,
  open: PropTypes.bool,
  placeholder: PropTypes.string,
  position: PropTypes.oneOf(POSITIONS),
  renderItem: PropTypes.func,
  renderSelectedItem: PropTypes.func,
  search: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
  searchQuery: PropTypes.string,
  searchInput: customPropTypes.itemShorthand,
  toggleIndicator: customPropTypes.itemShorthandWithoutJSX,
  triggerButton: customPropTypes.itemShorthand,
  unstable_pinned: PropTypes.bool,
  value: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand])
}));

_defineProperty(Dropdown, "defaultProps", {
  align: 'start',
  as: 'div',
  checkableIndicator: 'stardust-checkmark',
  clearIndicator: 'stardust-close',
  itemToString: function itemToString(item) {
    if (!item || React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  itemToValue: function itemToValue(item) {
    if (!item || React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  position: 'below',
  toggleIndicator: {},
  triggerButton: {}
});

_defineProperty(Dropdown, "autoControlledProps", ['activeSelectedIndex', 'highlightedIndex', 'open', 'searchQuery', 'value']);

_defineProperty(Dropdown, "Item", DropdownItem);

_defineProperty(Dropdown, "SearchInput", DropdownSearchInput);

_defineProperty(Dropdown, "SelectedItem", DropdownSelectedItem);

Dropdown.slotClassNames = {
  clearIndicator: "".concat(Dropdown.className, "__clear-indicator"),
  container: "".concat(Dropdown.className, "__container"),
  toggleIndicator: "".concat(Dropdown.className, "__toggle-indicator"),
  item: "".concat(Dropdown.className, "__item"),
  itemsList: "".concat(Dropdown.className, "__items-list"),
  searchInput: "".concat(Dropdown.className, "__searchinput"),
  selectedItem: "".concat(Dropdown.className, "__selecteditem"),
  selectedItems: "".concat(Dropdown.className, "__selected-items"),
  triggerButton: "".concat(Dropdown.className, "__trigger-button")
  /**
   * A Dropdown allows user to select one or more values from a list of options.
   * Can be created with search and multi-selection capabilities.
   *
   * @accessibility
   * Implements [ARIA Combo Box](https://www.w3.org/TR/wai-aria-practices-1.1/#combobox) design pattern, uses aria-live to announce state changes.
   * @accessibilityIssues
   * [Issue 991203: VoiceOver doesn't narrate properly elements in the input/combobox](https://bugs.chromium.org/p/chromium/issues/detail?id=991203)
   */

};
export default withSafeTypeForAs(Dropdown);