import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _get from "lodash/get";
import _toNumber from "lodash/toNumber";
import { sliderBehavior } from '@stardust-ui/accessibility';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import { handleRef, Ref } from '@stardust-ui/react-component-ref';
import cx from 'classnames';
import { applyAccessibilityKeyHandlers, AutoControlledComponent, commonPropTypes, partitionHTMLProps, setWhatInputSource } from '../../lib';
import { withSafeTypeForAs } from '../../types';
import Box from '../Box/Box';

var processInputValues = function processInputValues(p) {
  var min = _toNumber(p.min);

  var max = _toNumber(p.max);

  var value = _toNumber(p.value);

  if (isNaN(min)) min = Number(Slider.defaultProps.min);
  if (isNaN(max)) max = Number(Slider.defaultProps.max);
  value = isNaN(value) ? min + (max - min) / 2 : Math.min(max, Math.max(min, value));
  var valueAsPercentage = "".concat(100 * (value - min) / (max - min), "%");
  return {
    min: min,
    max: max,
    value: value,
    valueAsPercentage: valueAsPercentage
  };
};

var Slider =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Slider, _AutoControlledCompon);

  function Slider() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Slider);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Slider)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "inputRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "handleInputOverrides", function () {
      return {
        onChange: function onChange(e) {
          var value = _get(e, 'target.value');

          _invoke(_this.props, 'onChange', e, Object.assign({}, _this.props, {
            value: value
          }));

          _this.setState({
            value: value
          });
        },
        onMouseDown: function onMouseDown(e) {
          setWhatInputSource('mouse');

          _invoke(_this.props, 'onMouseDown', e, _this.props);
        }
      };
    });

    return _this;
  }

  _createClass(Slider, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        value: 50
      };
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref) {
      var _this2 = this;

      var ElementType = _ref.ElementType,
          classes = _ref.classes,
          accessibility = _ref.accessibility,
          rtl = _ref.rtl,
          styles = _ref.styles,
          unhandledProps = _ref.unhandledProps;
      var _this$props = this.props,
          input = _this$props.input,
          inputRef = _this$props.inputRef,
          step = _this$props.step;

      var _partitionHTMLProps = partitionHTMLProps(unhandledProps),
          _partitionHTMLProps2 = _slicedToArray(_partitionHTMLProps, 2),
          htmlInputProps = _partitionHTMLProps2[0],
          restProps = _partitionHTMLProps2[1];

      var type = 'range';

      var _processInputValues = processInputValues({
        min: this.props.min,
        max: this.props.max,
        value: this.state.value || ''
      }),
          min = _processInputValues.min,
          max = _processInputValues.max,
          value = _processInputValues.value,
          valueAsPercentage = _processInputValues.valueAsPercentage; // we need 2 wrappers around the slider rail, track, input and thumb slots to achieve correct component sizes


      return React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, restProps), React.createElement("div", {
        className: cx(Slider.slotClassNames.inputWrapper, classes.inputWrapper)
      }, React.createElement("span", {
        className: cx(Slider.slotClassNames.rail, classes.rail)
      }), React.createElement("span", {
        className: cx(Slider.slotClassNames.track, classes.track),
        style: {
          width: valueAsPercentage
        }
      }), React.createElement(Ref, {
        innerRef: function innerRef(inputElement) {
          handleRef(_this2.inputRef, inputElement);
          handleRef(inputRef, inputElement);
        }
      }, Box.create(input || type, {
        defaultProps: function defaultProps() {
          return Object.assign({}, htmlInputProps, accessibility.attributes.input, {
            className: Slider.slotClassNames.input,
            as: 'input',
            min: min,
            max: max,
            step: step,
            type: type,
            value: value,
            styles: styles.input
          }, applyAccessibilityKeyHandlers(accessibility.keyHandlers.input, htmlInputProps));
        },
        overrideProps: this.handleInputOverrides
      })), React.createElement("span", {
        className: cx(Slider.slotClassNames.thumb, classes.thumb),
        style: _defineProperty({}, rtl ? 'right' : 'left', valueAsPercentage)
      })));
    }
  }]);

  return Slider;
}(AutoControlledComponent);

_defineProperty(Slider, "displayName", 'Slider');

_defineProperty(Slider, "className", 'ui-slider');

_defineProperty(Slider, "slotClassNames", void 0);

_defineProperty(Slider, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  content: false
}), {
  defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  fluid: PropTypes.bool,
  getA11yValueMessageOnChange: PropTypes.func,
  input: customPropTypes.itemShorthand,
  inputRef: customPropTypes.ref,
  max: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  min: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  onChange: PropTypes.func,
  step: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  vertical: PropTypes.bool
}));

_defineProperty(Slider, "defaultProps", {
  accessibility: sliderBehavior,
  getA11yValueMessageOnChange: function getA11yValueMessageOnChange(_ref3) {
    var value = _ref3.value;
    return String(value);
  },
  max: 100,
  min: 0,
  step: 1
});

_defineProperty(Slider, "autoControlledProps", ['value']);

Slider.slotClassNames = {
  input: "".concat(Slider.className, "__input"),
  inputWrapper: "".concat(Slider.className, "__input-wrapper"),
  rail: "".concat(Slider.className, "__rail"),
  thumb: "".concat(Slider.className, "__thumb"),
  track: "".concat(Slider.className, "__track")
  /**
   * A Slider represents an input that allows user to choose a value from within a specific range.
   *
   * @accessibility
   * Implements [ARIA Slider](https://www.w3.org/TR/wai-aria-practices-1.1/#slider) design pattern.
   * @accessibilityIssues
   * [Slider - JAWS narrates slider value twice when using PageUp / PageDown](https://github.com/FreedomScientific/VFO-standards-support/issues/220)
   * [Slider - JAWS narrates current and new value in vertical slider](https://github.com/FreedomScientific/VFO-standards-support/issues/219)
   */

};
export default withSafeTypeForAs(Slider);