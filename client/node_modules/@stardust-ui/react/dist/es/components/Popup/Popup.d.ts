import { Accessibility } from '@stardust-ui/accessibility';
import { AutoFocusZoneProps, FocusTrapZoneProps } from '@stardust-ui/react-bindings';
import { NodeRef } from '@stardust-ui/react-component-nesting-registry';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { AutoControlledComponent, RenderResultConfig, ChildrenComponentProps, ContentComponentProps, StyledComponentProps } from '../../lib';
import { ComponentEventHandler, ShorthandValue } from '../../types';
import { PositioningProps, PopperChildrenProps } from '../../lib/positioner';
import { PopupContentProps } from './PopupContent';
import { ReactAccessibilityBehavior } from '../../lib/accessibility/reactTypes';
import { ShorthandFactory } from '../../lib/factories';
export declare type PopupEvents = 'click' | 'hover' | 'focus' | 'context';
export declare type RestrictedClickEvents = 'click' | 'focus';
export declare type RestrictedHoverEvents = 'hover' | 'focus' | 'context';
export declare type PopupEventsArray = RestrictedClickEvents[] | RestrictedHoverEvents[];
export interface PopupSlotClassNames {
    content: string;
}
export interface PopupProps extends StyledComponentProps<PopupProps>, ChildrenComponentProps, ContentComponentProps<ShorthandValue<PopupContentProps>>, PositioningProps {
    /**
     * Accessibility behavior if overridden by the user.
     * @available dialogBehavior
     */
    accessibility?: Accessibility;
    /** Additional CSS class name(s) to apply.  */
    className?: string;
    /** Initial value for 'open'. */
    defaultOpen?: boolean;
    /** Whether the Popup should be rendered inline with the trigger or in the body. */
    inline?: boolean;
    /** Existing document the popup should add listeners. */
    mountDocument?: Document;
    /** Existing element the popup should be bound to. */
    mountNode?: HTMLElement;
    /** Delay in ms for the mouse leave event, before the popup will be closed. */
    mouseLeaveDelay?: number;
    /** Events triggering the popup. */
    on?: PopupEvents | PopupEventsArray;
    /** Defines whether popup is displayed. */
    open?: boolean;
    /**
     * Event for request to change 'open' value.
     * @param {SyntheticEvent} event - React's original SyntheticEvent.
     * @param {object} data - All props and proposed value.
     */
    onOpenChange?: ComponentEventHandler<PopupProps>;
    /** A popup can show a pointer to trigger. */
    pointing?: boolean;
    /**
     * Function to render popup content.
     * @param {Function} updatePosition - function to request popup position update.
     */
    renderContent?: (updatePosition: Function) => ShorthandValue<PopupContentProps>;
    /**
     * DOM element that should be used as popup's target - instead of 'trigger' element that is used by default.
     */
    target?: HTMLElement;
    /** Element to be rendered in-place where the popup is defined. */
    trigger?: JSX.Element;
    /** Whether the trigger should be tabbable */
    tabbableTrigger?: boolean;
    /** Ref for Popup content DOM node. */
    contentRef?: React.Ref<HTMLElement>;
    /** Controls whether or not focus trap should be applied, using boolean or FocusTrapZoneProps type value. */
    trapFocus?: boolean | FocusTrapZoneProps;
    /** Controls whether or not auto focus should be applied, using boolean or AutoFocusZoneProps type value. */
    autoFocus?: boolean | AutoFocusZoneProps;
}
export interface PopupState {
    open: boolean;
    isOpenedByRightClick: boolean;
}
/**
 * A Popup displays a non-modal, often rich content, on top of its target element.
 */
export default class Popup extends AutoControlledComponent<PopupProps, PopupState> {
    static displayName: string;
    static className: string;
    static create: ShorthandFactory<PopupProps>;
    static slotClassNames: PopupSlotClassNames;
    static Content: {
        <Tag>(x: {
            as: Tag;
        } & PopupContentProps & {
            [K: string]: any;
        }): JSX.Element;
        (x: {
            accessibility?: Accessibility<any>;
            onMouseEnter?: ComponentEventHandler<PopupContentProps>;
            onMouseLeave?: ComponentEventHandler<PopupContentProps>;
            placement?: import("popper.js").default.Placement;
            pointing?: boolean;
            pointerRef?: React.Ref<HTMLDivElement>;
            trapFocus?: boolean | FocusTrapZoneProps;
            autoFocus?: boolean | AutoFocusZoneProps;
            className?: string;
            design?: import("../..").ComponentDesign;
            styles?: import("../..").ComponentSlotStyle<any, any>;
            variables?: any;
            animation?: import("../..").AnimationProp;
            children?: React.ReactNode;
            content?: React.ReactNode;
            ref?: React.LegacyRef<HTMLDivElement>;
            key?: string | number;
            defaultChecked?: boolean;
            defaultValue?: string | string[];
            suppressContentEditableWarning?: boolean;
            suppressHydrationWarning?: boolean;
            accessKey?: string;
            contentEditable?: boolean;
            contextMenu?: string;
            dir?: string;
            draggable?: boolean;
            hidden?: boolean;
            id?: string;
            lang?: string;
            placeholder?: string;
            slot?: string;
            spellCheck?: boolean;
            style?: React.CSSProperties;
            tabIndex?: number;
            title?: string;
            inputMode?: string;
            is?: string;
            radioGroup?: string;
            role?: string;
            about?: string;
            datatype?: string;
            inlist?: any;
            prefix?: string;
            property?: string;
            resource?: string;
            typeof?: string;
            vocab?: string;
            autoCapitalize?: string;
            autoCorrect?: string;
            autoSave?: string;
            color?: string;
            itemProp?: string;
            itemScope?: boolean;
            itemType?: string;
            itemID?: string;
            itemRef?: string;
            results?: number;
            security?: string;
            unselectable?: "on" | "off";
            'aria-activedescendant'?: string;
            'aria-atomic'?: boolean | "false" | "true";
            'aria-autocomplete'?: "none" | "both" | "inline" | "list";
            'aria-busy'?: boolean | "false" | "true";
            'aria-checked'?: boolean | "mixed" | "false" | "true";
            'aria-colcount'?: number;
            'aria-colindex'?: number;
            'aria-colspan'?: number;
            'aria-controls'?: string;
            'aria-current'?: boolean | "time" | "page" | "false" | "true" | "step" | "location" | "date";
            'aria-describedby'?: string;
            'aria-details'?: string;
            'aria-disabled'?: boolean | "false" | "true";
            'aria-dropeffect'?: "link" | "none" | "copy" | "move" | "execute" | "popup";
            'aria-errormessage'?: string;
            'aria-expanded'?: boolean | "false" | "true";
            'aria-flowto'?: string;
            'aria-grabbed'?: boolean | "false" | "true";
            'aria-haspopup'?: boolean | "dialog" | "menu" | "grid" | "listbox" | "false" | "true" | "tree";
            'aria-hidden'?: boolean | "false" | "true";
            'aria-invalid'?: boolean | "false" | "true" | "grammar" | "spelling";
            'aria-keyshortcuts'?: string;
            'aria-label'?: string;
            'aria-labelledby'?: string;
            'aria-level'?: number;
            'aria-live'?: "off" | "assertive" | "polite";
            'aria-modal'?: boolean | "false" | "true";
            'aria-multiline'?: boolean | "false" | "true";
            'aria-multiselectable'?: boolean | "false" | "true";
            'aria-orientation'?: "horizontal" | "vertical";
            'aria-owns'?: string;
            'aria-placeholder'?: string;
            'aria-posinset'?: number;
            'aria-pressed'?: boolean | "mixed" | "false" | "true";
            'aria-readonly'?: boolean | "false" | "true";
            'aria-relevant'?: "all" | "text" | "additions" | "additions text" | "removals";
            'aria-required'?: boolean | "false" | "true";
            'aria-roledescription'?: string;
            'aria-rowcount'?: number;
            'aria-rowindex'?: number;
            'aria-rowspan'?: number;
            'aria-selected'?: boolean | "false" | "true";
            'aria-setsize'?: number;
            'aria-sort'?: "none" | "ascending" | "descending" | "other";
            'aria-valuemax'?: number;
            'aria-valuemin'?: number;
            'aria-valuenow'?: number;
            'aria-valuetext'?: string;
            dangerouslySetInnerHTML?: {
                __html: string;
            };
            onCopy?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onCopyCapture?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onCut?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onCutCapture?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onPaste?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onPasteCapture?: (event: React.ClipboardEvent<HTMLDivElement>) => void;
            onCompositionEnd?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onCompositionEndCapture?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onCompositionStart?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onCompositionStartCapture?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onCompositionUpdate?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onCompositionUpdateCapture?: (event: React.CompositionEvent<HTMLDivElement>) => void;
            onFocus?: (event: React.FocusEvent<HTMLDivElement>) => void;
            onFocusCapture?: (event: React.FocusEvent<HTMLDivElement>) => void;
            onBlur?: (event: React.FocusEvent<HTMLDivElement>) => void;
            onBlurCapture?: (event: React.FocusEvent<HTMLDivElement>) => void;
            onChange?: (event: React.FormEvent<HTMLDivElement>) => void;
            onChangeCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onBeforeInput?: (event: React.FormEvent<HTMLDivElement>) => void;
            onBeforeInputCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onInput?: (event: React.FormEvent<HTMLDivElement>) => void;
            onInputCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onReset?: (event: React.FormEvent<HTMLDivElement>) => void;
            onResetCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onSubmit?: (event: React.FormEvent<HTMLDivElement>) => void;
            onSubmitCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onInvalid?: (event: React.FormEvent<HTMLDivElement>) => void;
            onInvalidCapture?: (event: React.FormEvent<HTMLDivElement>) => void;
            onLoad?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onError?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onErrorCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onKeyDown?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onKeyDownCapture?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onKeyPress?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onKeyPressCapture?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onKeyUp?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onKeyUpCapture?: (event: React.KeyboardEvent<HTMLDivElement>) => void;
            onAbort?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onAbortCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onCanPlay?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onCanPlayCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onCanPlayThrough?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onCanPlayThroughCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onDurationChange?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onDurationChangeCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEmptied?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEmptiedCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEncrypted?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEncryptedCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEnded?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onEndedCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadedData?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadedDataCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadedMetadata?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadedMetadataCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadStart?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onLoadStartCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPause?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPauseCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPlay?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPlayCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPlaying?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onPlayingCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onProgress?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onProgressCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onRateChange?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onRateChangeCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSeeked?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSeekedCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSeeking?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSeekingCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onStalled?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onStalledCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSuspend?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSuspendCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onTimeUpdate?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onTimeUpdateCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onVolumeChange?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onVolumeChangeCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onWaiting?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onWaitingCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onClick?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onClickCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onContextMenu?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onContextMenuCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onDoubleClick?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onDoubleClickCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onDrag?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragEnd?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragEndCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragEnter?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragEnterCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragExit?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragExitCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragLeave?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragLeaveCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragOver?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragOverCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragStart?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDragStartCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDrop?: (event: React.DragEvent<HTMLDivElement>) => void;
            onDropCapture?: (event: React.DragEvent<HTMLDivElement>) => void;
            onMouseDown?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseDownCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseMove?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseMoveCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseOut?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseOutCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseOver?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseOverCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseUp?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onMouseUpCapture?: (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => void;
            onSelect?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onSelectCapture?: (event: React.SyntheticEvent<HTMLDivElement, Event>) => void;
            onTouchCancel?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchCancelCapture?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchEnd?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchEndCapture?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchMove?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchMoveCapture?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchStart?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onTouchStartCapture?: (event: React.TouchEvent<HTMLDivElement>) => void;
            onPointerDown?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerDownCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerMove?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerMoveCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerUp?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerUpCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerCancel?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerCancelCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerEnter?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerEnterCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerLeave?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerLeaveCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerOver?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerOverCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerOut?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onPointerOutCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onGotPointerCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onGotPointerCaptureCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onLostPointerCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onLostPointerCaptureCapture?: (event: React.PointerEvent<HTMLDivElement>) => void;
            onScroll?: (event: React.UIEvent<HTMLDivElement>) => void;
            onScrollCapture?: (event: React.UIEvent<HTMLDivElement>) => void;
            onWheel?: (event: React.WheelEvent<HTMLDivElement>) => void;
            onWheelCapture?: (event: React.WheelEvent<HTMLDivElement>) => void;
            onAnimationStart?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onAnimationStartCapture?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onAnimationEnd?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onAnimationEndCapture?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onAnimationIteration?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onAnimationIterationCapture?: (event: React.AnimationEvent<HTMLDivElement>) => void;
            onTransitionEnd?: (event: React.TransitionEvent<HTMLDivElement>) => void;
            onTransitionEndCapture?: (event: React.TransitionEvent<HTMLDivElement>) => void;
        }): JSX.Element;
    } & {
        contextType: any;
        displayName: string;
        className: string;
        handledProps: string[];
        unhandledProps: string[];
        create: ShorthandFactory<PopupContentProps>;
        _handledPropsCache: string[];
        slotClassNames: import("./PopupContent").PopupContentSlotClassNames;
    };
    static propTypes: {
        align: PropTypes.Requireable<import("../../lib/positioner").Alignment>;
        defaultOpen: PropTypes.Requireable<boolean>;
        inline: PropTypes.Requireable<boolean>;
        mountDocument: PropTypes.Requireable<object>;
        mountNode: (props: Record<string, any>, propName: string) => Error;
        mouseLeaveDelay: PropTypes.Requireable<number>;
        offset: PropTypes.Requireable<string>;
        on: PropTypes.Requireable<string | string[]>;
        open: PropTypes.Requireable<boolean>;
        onOpenChange: PropTypes.Requireable<(...args: any[]) => any>;
        pointing: PropTypes.Requireable<boolean>;
        position: PropTypes.Requireable<import("../../lib/positioner").Position>;
        renderContent: PropTypes.Requireable<(...args: any[]) => any>;
        target: PropTypes.Requireable<any>;
        trigger: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        tabbableTrigger: PropTypes.Requireable<boolean>;
        unstable_pinned: PropTypes.Requireable<boolean>;
        content: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        contentRef: PropTypes.Requireable<object>;
        trapFocus: PropTypes.Requireable<boolean | object>;
        autoFocus: PropTypes.Requireable<boolean | object>;
        styles: PropTypes.Requireable<object>;
        variables: PropTypes.Requireable<object>;
        design: PropTypes.Requireable<PropTypes.InferProps<{
            position: PropTypes.Requireable<string>;
            display: PropTypes.Requireable<string>;
            top: PropTypes.Requireable<string>;
            right: PropTypes.Requireable<string>;
            bottom: PropTypes.Requireable<string>;
            left: PropTypes.Requireable<string>;
            padding: PropTypes.Requireable<string>;
            paddingTop: PropTypes.Requireable<string>;
            paddingRight: PropTypes.Requireable<string>;
            paddingBottom: PropTypes.Requireable<string>;
            paddingLeft: PropTypes.Requireable<string>;
            margin: PropTypes.Requireable<string>;
            marginTop: PropTypes.Requireable<string>;
            marginRight: PropTypes.Requireable<string>;
            marginBottom: PropTypes.Requireable<string>;
            marginLeft: PropTypes.Requireable<string>;
            width: PropTypes.Requireable<string>;
            height: PropTypes.Requireable<string>;
            minWidth: PropTypes.Requireable<string>;
            maxWidth: PropTypes.Requireable<string>;
            minHeight: PropTypes.Requireable<string>;
            maxHeight: PropTypes.Requireable<string>;
        }>>;
        color: PropTypes.Requireable<string>;
        className: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        as: PropTypes.Requireable<PropTypes.ReactComponentLike>;
        animation: PropTypes.Requireable<any>;
        accessibility: PropTypes.Requireable<object>;
    };
    static defaultProps: PopupProps;
    static autoControlledProps: string[];
    pointerTargetRef: React.RefObject<HTMLElement>;
    triggerRef: React.MutableRefObject<HTMLElement>;
    triggerFocusableDomElement: any;
    popupDomElement: any;
    rightClickReferenceObject: any;
    closeTimeoutId: any;
    actionHandlers: {
        closeAndFocusTrigger: (e: any) => void;
        close: (e: any) => void;
        toggle: (e: any) => void;
        open: (e: any) => void;
        preventScroll: (e: any) => void;
    };
    componentDidMount(): void;
    renderComponent({ classes, rtl, accessibility, }: RenderResultConfig<PopupProps>): React.ReactNode;
    handleDocumentClick: (getRefs: Function) => (e: any) => void;
    handleDocumentKeyDown: (getRefs: Function) => (e: KeyboardEvent) => void;
    isOutsidePopupElementAndOutsideTriggerElement(refs: NodeRef[], e: any): boolean;
    isOutsidePopupElement(refs: NodeRef[], e: any): boolean;
    getTriggerProps(triggerElement: any): any;
    getContentProps: (predefinedProps?: any) => any;
    shouldBlurClose: (e: any) => boolean;
    renderTrigger(accessibility: any): JSX.Element;
    renderPopupContent(popupPositionClasses: string, rtl: boolean, accessibility: ReactAccessibilityBehavior): JSX.Element;
    renderPopperChildren: (popupPositionClasses: string, rtl: boolean, accessibility: ReactAccessibilityBehavior, { placement, scheduleUpdate }: PopperChildrenProps) => JSX.Element;
    dismissOnScroll: (e: Event) => void;
    trySetOpen(newValue: boolean, eventArgs: any): void;
    setPopupOpen(newOpen: any, e: any): void;
    schedulePopupClose: (e: any) => void;
    close: (e: any, onClose?: Function) => void;
    /**
     * Save DOM element which had focus before Popup opens.
     * Can be either trigger DOM element itself or the element inside it.
     */
    updateTriggerFocusableDomElement(): void;
    updateContextPosition(nativeEvent: MouseEvent): void;
}
