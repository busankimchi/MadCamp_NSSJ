import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _includes from "lodash/includes";
import _isArray from "lodash/isArray";
import _some from "lodash/some";
import _invoke from "lodash/invoke";
import { popupBehavior } from '@stardust-ui/accessibility';
import { EventListener } from '@stardust-ui/react-component-event-listener';
import { Unstable_NestingAuto } from '@stardust-ui/react-component-nesting-registry';
import { handleRef, toRefObject, Ref } from '@stardust-ui/react-component-ref';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import * as keyboardKey from 'keyboard-key';
import { applyAccessibilityKeyHandlers, childrenExist, AutoControlledComponent, commonPropTypes, isFromKeyboard, doesNodeContainClick, setWhatInputSource } from '../../lib';
import { ALIGNMENTS, POSITIONS, Popper } from '../../lib/positioner';
import PopupContent from './PopupContent';
import { createShorthandFactory } from '../../lib/factories';
import createReferenceFromContextClick from './createReferenceFromContextClick';
import isRightClick from '../../lib/isRightClick';
import PortalInner from '../Portal/PortalInner';

/**
 * A Popup displays a non-modal, often rich content, on top of its target element.
 */
var Popup =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Popup, _AutoControlledCompon);

  function Popup() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Popup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Popup)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "pointerTargetRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "triggerRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "triggerFocusableDomElement", null);

    _defineProperty(_assertThisInitialized(_this), "popupDomElement", null);

    _defineProperty(_assertThisInitialized(_this), "rightClickReferenceObject", null);

    _defineProperty(_assertThisInitialized(_this), "closeTimeoutId", void 0);

    _defineProperty(_assertThisInitialized(_this), "actionHandlers", {
      closeAndFocusTrigger: function closeAndFocusTrigger(e) {
        _this.close(e, function () {
          return _invoke(_this.triggerFocusableDomElement, 'focus');
        });
      },
      close: function close(e) {
        _this.close(e);
      },
      toggle: function toggle(e) {
        e.preventDefault();

        _this.trySetOpen(!_this.state.open, e);
      },
      open: function open(e) {
        e.preventDefault();

        _this.setPopupOpen(true, e);
      },
      preventScroll: function preventScroll(e) {
        e.preventDefault();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleDocumentClick", function (getRefs) {
      return function (e) {
        if (_this.state.isOpenedByRightClick && _this.isOutsidePopupElement(getRefs(), e)) {
          _this.trySetOpen(false, e);

          return;
        }

        if (_this.isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
          _this.trySetOpen(false, e);
        }
      };
    });

    _defineProperty(_assertThisInitialized(_this), "handleDocumentKeyDown", function (getRefs) {
      return function (e) {
        var keyCode = keyboardKey.getCode(e);
        var isMatchingKey = keyCode === keyboardKey.Enter || keyCode === keyboardKey.Spacebar;

        if (isMatchingKey && _this.isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
          _this.trySetOpen(false, e);
        } // if focus was lost from Popup and moved to body, for e.g. when click on popup content
        // and ESC is pressed, the last opened Popup should get closed and the trigger should get focus


        var lastContentRef = getRefs().pop();
        var isLastOpenedPopup = lastContentRef && lastContentRef.current === _this.popupDomElement;
        var activeDocument = _this.props.mountDocument || _this.context.target;
        var bodyHasFocus = activeDocument.activeElement === activeDocument.body;

        if (keyCode === keyboardKey.Escape && bodyHasFocus && isLastOpenedPopup) {
          _this.close(e, function () {
            return _invoke(_this.triggerFocusableDomElement, 'focus');
          });
        }
      };
    });

    _defineProperty(_assertThisInitialized(_this), "getContentProps", function (predefinedProps) {
      var contentHandlerProps = {};
      var on = _this.props.on;
      var normalizedOn = _isArray(on) ? on : [on];
      /**
       * The focus is adding the focus and blur events on the content
       */

      if (_includes(normalizedOn, 'focus')) {
        contentHandlerProps.onFocus = function (e, contentProps) {
          _this.trySetOpen(true, e);

          predefinedProps && _invoke(predefinedProps, 'onFocus', e, contentProps);
        };

        contentHandlerProps.onBlur = function (e, contentProps) {
          if (_this.shouldBlurClose(e)) {
            _this.trySetOpen(false, e);
          }

          predefinedProps && _invoke(predefinedProps, 'onBlur', e, contentProps);
        };
      }
      /**
       * The hover is adding the mouseEnter, mouseLeave and click event (always opening on click)
       */


      if (_includes(normalizedOn, 'hover')) {
        contentHandlerProps.onMouseEnter = function (e, contentProps) {
          _this.setPopupOpen(true, e);

          predefinedProps && _invoke(predefinedProps, 'onMouseEnter', e, contentProps);
        };

        contentHandlerProps.onMouseLeave = function (e, contentProps) {
          _this.setPopupOpen(false, e);

          predefinedProps && _invoke(predefinedProps, 'onMouseLeave', e, contentProps);
        };

        contentHandlerProps.onClick = function (e, contentProps) {
          _this.setPopupOpen(true, e);

          predefinedProps && _invoke(predefinedProps, 'onClick', e, contentProps);
        };
      }

      return contentHandlerProps;
    });

    _defineProperty(_assertThisInitialized(_this), "shouldBlurClose", function (e) {
      return !e.currentTarget || !_this.popupDomElement || !e.currentTarget.contains(e.relatedTarget) && !_this.popupDomElement.contains(e.relatedTarget);
    });

    _defineProperty(_assertThisInitialized(_this), "renderPopperChildren", function (popupPositionClasses, rtl, accessibility, _ref) {
      var placement = _ref.placement,
          scheduleUpdate = _ref.scheduleUpdate;
      var _this$props = _this.props,
          propsContent = _this$props.content,
          renderContent = _this$props.renderContent,
          contentRef = _this$props.contentRef,
          mountDocument = _this$props.mountDocument,
          pointing = _this$props.pointing,
          trapFocus = _this$props.trapFocus,
          autoFocus = _this$props.autoFocus;
      var content = renderContent ? renderContent(scheduleUpdate) : propsContent;
      var targetRef = toRefObject(mountDocument || _this.context.target);
      var popupContent = Popup.Content.create(content || {}, {
        defaultProps: function defaultProps() {
          return Object.assign({}, rtl && {
            dir: 'rtl'
          }, accessibility.attributes.popup, accessibility.keyHandlers.popup, {
            className: popupPositionClasses
          }, _this.getContentProps(), {
            placement: placement,
            pointing: pointing,
            pointerRef: _this.pointerTargetRef,
            trapFocus: trapFocus,
            autoFocus: autoFocus
          });
        },
        overrideProps: _this.getContentProps
      });
      return React.createElement(Unstable_NestingAuto, null, function (getRefs, nestingRef) {
        return React.createElement(React.Fragment, null, React.createElement(Ref, {
          innerRef: function innerRef(domElement) {
            _this.popupDomElement = domElement;
            handleRef(contentRef, domElement);
            nestingRef.current = domElement;
          }
        }, popupContent), React.createElement(EventListener, {
          listener: _this.handleDocumentClick(getRefs),
          targetRef: targetRef,
          type: "click",
          capture: true
        }), React.createElement(EventListener, {
          listener: _this.handleDocumentClick(getRefs),
          targetRef: targetRef,
          type: "contextmenu",
          capture: true
        }), React.createElement(EventListener, {
          listener: _this.handleDocumentKeyDown(getRefs),
          targetRef: targetRef,
          type: "keydown",
          capture: true
        }), _this.state.isOpenedByRightClick && React.createElement(React.Fragment, null, React.createElement(EventListener, {
          listener: _this.dismissOnScroll,
          targetRef: targetRef,
          type: "wheel",
          capture: true
        }), React.createElement(EventListener, {
          listener: _this.dismissOnScroll,
          targetRef: targetRef,
          type: "touchmove",
          capture: true
        })));
      });
    });

    _defineProperty(_assertThisInitialized(_this), "dismissOnScroll", function (e) {
      _this.trySetOpen(false, e);
    });

    _defineProperty(_assertThisInitialized(_this), "schedulePopupClose", function (e) {
      var mouseLeaveDelay = _this.props.mouseLeaveDelay;
      _this.closeTimeoutId = setTimeout(function () {
        _this.trySetOpen(false, e);
      }, mouseLeaveDelay);
    });

    _defineProperty(_assertThisInitialized(_this), "close", function (e, onClose) {
      if (_this.state.open) {
        _this.trySetOpen(false, e);

        onClose && onClose();
        e.stopPropagation();
      }
    });

    return _this;
  }

  _createClass(Popup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props,
          inline = _this$props2.inline,
          trapFocus = _this$props2.trapFocus,
          autoFocus = _this$props2.autoFocus;

      if (process.env.NODE_ENV !== 'production') {
        if (inline && trapFocus) {
          console.warn('Using "trapFocus" in inline popup leads to broken behavior for screen reader users.');
        }

        if (!inline && autoFocus) {
          console.warn('Beware, "autoFocus" prop will just grab focus at the moment of mount and will not trap it. As user is able to TAB out from popup, better use "inline" prop to keep correct tab order.');
        }
      }
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var classes = _ref2.classes,
          rtl = _ref2.rtl,
          accessibility = _ref2.accessibility;
      var _this$props3 = this.props,
          inline = _this$props3.inline,
          mountNode = _this$props3.mountNode;
      var open = this.state.open;
      var popupContent = open && this.renderPopupContent(classes.popup, rtl, accessibility);
      return React.createElement(React.Fragment, null, this.renderTrigger(accessibility), open && (inline ? popupContent : React.createElement(PortalInner, {
        mountNode: mountNode
      }, popupContent)));
    }
  }, {
    key: "isOutsidePopupElementAndOutsideTriggerElement",
    value: function isOutsidePopupElementAndOutsideTriggerElement(refs, e) {
      var isOutsidePopupElement = this.isOutsidePopupElement(refs, e);
      var isOutsideTriggerElement = this.triggerRef.current && !doesNodeContainClick(this.triggerRef.current, e, this.context.target);
      return isOutsidePopupElement && isOutsideTriggerElement;
    }
  }, {
    key: "isOutsidePopupElement",
    value: function isOutsidePopupElement(refs, e) {
      var _this2 = this;

      var isInsideNested = _some(refs, function (childRef) {
        return doesNodeContainClick(childRef.current, e, _this2.context.target);
      });

      var isOutsidePopupElement = this.popupDomElement && !isInsideNested;
      return isOutsidePopupElement;
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps(triggerElement) {
      var _this3 = this;

      var triggerProps = {};
      var on = this.props.on;
      var normalizedOn = _isArray(on) ? on : [on];
      /**
       * The focus is adding the focus, blur and click event (always opening on click)
       * If focus and context are provided, there is no need to add onClick
       */

      if (_includes(normalizedOn, 'focus')) {
        triggerProps.onFocus = function (e) {
          if (isFromKeyboard()) {
            _this3.trySetOpen(true, e);
          }

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onFocus', e].concat(args));
        };

        triggerProps.onBlur = function (e) {
          if (_this3.shouldBlurClose(e)) {
            _this3.trySetOpen(false, e);
          }

          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
        };

        if (!_includes(normalizedOn, 'context')) {
          triggerProps.onClick = function (e) {
            _this3.setPopupOpen(true, e);

            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }

            _invoke.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
          };
        }
      }
      /**
       * The click is toggling the open state of the popup
       */


      if (_includes(normalizedOn, 'click')) {
        triggerProps.onClick = function (e) {
          _this3.trySetOpen(!_this3.state.open, e);

          for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            args[_key5 - 1] = arguments[_key5];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
        };
      }
      /**
       * The context is opening the popup
       */


      if (_includes(normalizedOn, 'context')) {
        triggerProps.onContextMenu = function (e) {
          _this3.setPopupOpen(!_this3.state.open, e);

          for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
            args[_key6 - 1] = arguments[_key6];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onContextMenu', e].concat(args));

          e.preventDefault();
        };
      }
      /**
       * The hover is adding the mouseEnter, mouseLeave, blur and click event (always opening on click)
       * If hover and context are provided, there is no need to add onClick
       */


      if (_includes(normalizedOn, 'hover')) {
        triggerProps.onMouseEnter = function (e) {
          _this3.setPopupOpen(true, e);

          setWhatInputSource('mouse');

          for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
            args[_key7 - 1] = arguments[_key7];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onMouseEnter', e].concat(args));
        };

        triggerProps.onMouseLeave = function (e) {
          _this3.setPopupOpen(false, e);

          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
            args[_key8 - 1] = arguments[_key8];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onMouseLeave', e].concat(args));
        };

        if (!_includes(normalizedOn, 'context')) {
          triggerProps.onClick = function (e) {
            _this3.setPopupOpen(true, e);

            for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
              args[_key9 - 1] = arguments[_key9];
            }

            _invoke.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
          };
        }

        triggerProps.onBlur = function (e) {
          if (_this3.shouldBlurClose(e)) {
            _this3.trySetOpen(false, e);
          }

          for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
            args[_key10 - 1] = arguments[_key10];
          }

          _invoke.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
        };
      }

      return triggerProps;
    }
  }, {
    key: "renderTrigger",
    value: function renderTrigger(accessibility) {
      var _this$props4 = this.props,
          children = _this$props4.children,
          trigger = _this$props4.trigger;
      var triggerElement = childrenExist(children) ? children : trigger;
      var triggerProps = this.getTriggerProps(triggerElement);
      return triggerElement && React.createElement(Ref, {
        innerRef: this.triggerRef
      }, React.cloneElement(triggerElement, Object.assign({}, accessibility.attributes.trigger, triggerProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.trigger, triggerProps))));
    }
  }, {
    key: "renderPopupContent",
    value: function renderPopupContent(popupPositionClasses, rtl, accessibility) {
      var _this$props5 = this.props,
          align = _this$props5.align,
          position = _this$props5.position,
          offset = _this$props5.offset,
          target = _this$props5.target,
          unstable_pinned = _this$props5.unstable_pinned;
      return React.createElement(Popper, {
        pointerTargetRef: this.pointerTargetRef,
        align: align,
        position: position,
        offset: offset,
        rtl: rtl,
        unstable_pinned: unstable_pinned,
        targetRef: this.rightClickReferenceObject || (target ? toRefObject(target) : this.triggerRef),
        children: this.renderPopperChildren.bind(this, popupPositionClasses, rtl, accessibility)
      });
    }
  }, {
    key: "trySetOpen",
    value: function trySetOpen(newValue, eventArgs) {
      var isOpenedByRightClick = newValue && isRightClick(eventArgs); // when new state 'open' === 'true', save the last focused element

      if (newValue) {
        this.updateTriggerFocusableDomElement();
        this.updateContextPosition(isOpenedByRightClick && eventArgs.nativeEvent);
      }

      this.setState({
        open: newValue,
        isOpenedByRightClick: isOpenedByRightClick
      });

      _invoke(this.props, 'onOpenChange', eventArgs, Object.assign({}, this.props, {
        open: newValue
      }));
    }
  }, {
    key: "setPopupOpen",
    value: function setPopupOpen(newOpen, e) {
      clearTimeout(this.closeTimeoutId);
      newOpen ? this.trySetOpen(true, e) : this.schedulePopupClose(e);
    }
  }, {
    key: "updateTriggerFocusableDomElement",

    /**
     * Save DOM element which had focus before Popup opens.
     * Can be either trigger DOM element itself or the element inside it.
     */
    value: function updateTriggerFocusableDomElement() {
      var mountDocument = this.props.mountDocument;
      var activeDocument = mountDocument || this.context.target;
      var activeElement = activeDocument.activeElement;
      this.triggerFocusableDomElement = this.triggerRef.current.contains(activeElement) ? activeElement : this.triggerRef.current;
    }
  }, {
    key: "updateContextPosition",
    value: function updateContextPosition(nativeEvent) {
      this.rightClickReferenceObject = nativeEvent && createReferenceFromContextClick(nativeEvent);
    }
  }]);

  return Popup;
}(AutoControlledComponent);

_defineProperty(Popup, "displayName", 'Popup');

_defineProperty(Popup, "className", 'ui-popup');

_defineProperty(Popup, "create", void 0);

_defineProperty(Popup, "slotClassNames", {
  content: "".concat(Popup.className, "__content")
});

_defineProperty(Popup, "Content", PopupContent);

_defineProperty(Popup, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  animated: false,
  as: false,
  content: false
}), {
  align: PropTypes.oneOf(ALIGNMENTS),
  defaultOpen: PropTypes.bool,
  inline: PropTypes.bool,
  mountDocument: PropTypes.object,
  mountNode: customPropTypes.domNode,
  mouseLeaveDelay: PropTypes.number,
  offset: PropTypes.string,
  on: PropTypes.oneOfType([PropTypes.oneOf(['hover', 'click', 'focus', 'context']), PropTypes.arrayOf(PropTypes.oneOf(['click', 'focus', 'context'])), PropTypes.arrayOf(PropTypes.oneOf(['hover', 'focus', 'context']))]),
  open: PropTypes.bool,
  onOpenChange: PropTypes.func,
  pointing: PropTypes.bool,
  position: PropTypes.oneOf(POSITIONS),
  renderContent: PropTypes.func,
  target: PropTypes.any,
  trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.any]),
  tabbableTrigger: PropTypes.bool,
  unstable_pinned: PropTypes.bool,
  content: customPropTypes.shorthandAllowingChildren,
  contentRef: customPropTypes.ref,
  trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
  autoFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object])
}));

_defineProperty(Popup, "defaultProps", {
  accessibility: popupBehavior,
  align: 'start',
  position: 'above',
  on: 'click',
  mouseLeaveDelay: 500,
  tabbableTrigger: true
});

_defineProperty(Popup, "autoControlledProps", ['open']);

export { Popup as default };
Popup.create = createShorthandFactory({
  Component: Popup,
  mappedProp: 'content'
});