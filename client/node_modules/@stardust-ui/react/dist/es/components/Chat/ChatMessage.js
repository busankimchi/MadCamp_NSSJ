import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import _get from "lodash/get";
import { IS_FOCUSABLE_ATTRIBUTE, chatMessageBehavior, menuAsToolbarBehavior } from '@stardust-ui/accessibility';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import { Ref } from '@stardust-ui/react-component-ref';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import cx from 'classnames';
import { Popper } from '../../lib/positioner';
import { childrenExist, createShorthandFactory, UIComponent, commonPropTypes, rtlTextContainer, applyAccessibilityKeyHandlers } from '../../lib';
import { withSafeTypeForAs } from '../../types';
import Box from '../Box/Box';
import Label from '../Label/Label';
import Menu from '../Menu/Menu';
import Text from '../Text/Text';
import Reaction from '../Reaction/Reaction';

var ChatMessage =
/*#__PURE__*/
function (_UIComponent) {
  _inherits(ChatMessage, _UIComponent);

  function ChatMessage() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, ChatMessage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ChatMessage)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "updateActionsMenuPosition", function () {});

    _defineProperty(_assertThisInitialized(_this), "state", {
      focused: false,
      messageNode: null
    });

    _defineProperty(_assertThisInitialized(_this), "menuRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "actionHandlers", {
      // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
      // as navigation (only Tab key should work)
      preventDefault: function preventDefault(event) {
        event.preventDefault();
      },
      focus: function focus(event) {
        if (_this.state.messageNode) {
          _this.state.messageNode.focus();

          event.stopPropagation();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleFocus", function (e) {
      _this.updateActionsMenuPosition();

      _this.setState({
        focused: true
      });

      _invoke(_this.props, 'onFocus', e, _this.props);
    });

    _defineProperty(_assertThisInitialized(_this), "handleBlur", function (e) {
      // `this.state.focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
      // with keyboard the focused element will be changed and there is no way to use `:focus` selector
      var shouldPreserveFocusState = _invoke(e, 'currentTarget.contains', e.relatedTarget);

      _this.setState({
        focused: shouldPreserveFocusState
      });

      _invoke(_this.props, 'onBlur', e, _this.props);
    });

    _defineProperty(_assertThisInitialized(_this), "handleMouseEnter", function (e) {
      _this.updateActionsMenuPosition();

      _invoke(_this.props, 'onMouseEnter', e, _this.props);
    });

    _defineProperty(_assertThisInitialized(_this), "handleMessageRef", function (node) {
      return _this.setState({
        messageNode: node
      });
    });

    return _this;
  }

  _createClass(ChatMessage, [{
    key: "renderActionMenu",
    value: function renderActionMenu(actionMenu, styles) {
      var _this2 = this;

      var _this$props = this.props,
          overflow = _this$props.unstable_overflow,
          positionActionMenu = _this$props.positionActionMenu;
      var messageNode = this.state.messageNode;
      var actionMenuElement = Menu.create(actionMenu, {
        defaultProps: function defaultProps() {
          var _ref;

          return _ref = {}, _defineProperty(_ref, IS_FOCUSABLE_ATTRIBUTE, true), _defineProperty(_ref, "accessibility", menuAsToolbarBehavior), _defineProperty(_ref, "className", ChatMessage.slotClassNames.actionMenu), _defineProperty(_ref, "styles", styles.actionMenu), _ref;
        }
      });

      if (!actionMenuElement) {
        return actionMenuElement;
      }

      var menuRect = positionActionMenu && _invoke(this.menuRef.current, 'getBoundingClientRect') || {
        height: 0
      };
      var messageRect = positionActionMenu && _invoke(messageNode, 'getBoundingClientRect') || {
        height: 0
      };
      return React.createElement(Popper, {
        enabled: positionActionMenu,
        align: "end",
        modifiers: positionActionMenu && {
          // https://popper.js.org/popper-documentation.html#modifiers..flip.behavior
          // Forces to flip only in "top-*" positions
          flip: {
            behavior: ['top']
          },
          preventOverflow: Object.assign({
            escapeWithReference: false,
            // https://popper.js.org/popper-documentation.html#modifiers..preventOverflow.priority
            // Forces to stop prevent overflow on bottom and bottom
            priority: ['left', 'right']
          }, overflow && {
            boundariesElement: 'scrollParent',
            escapeWithReference: true,
            padding: {
              top: messageRect.height - menuRect.height
            }
          })
        },
        position: "above",
        positionFixed: overflow,
        targetRef: messageNode
      }, function (_ref2) {
        var scheduleUpdate = _ref2.scheduleUpdate;
        _this2.updateActionsMenuPosition = scheduleUpdate;
        return React.createElement(Ref, {
          innerRef: _this2.menuRef
        }, actionMenuElement);
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref3) {
      var ElementType = _ref3.ElementType,
          classes = _ref3.classes,
          accessibility = _ref3.accessibility,
          unhandledProps = _ref3.unhandledProps,
          styles = _ref3.styles;
      var _this$props2 = this.props,
          actionMenu = _this$props2.actionMenu,
          author = _this$props2.author,
          badge = _this$props2.badge,
          badgePosition = _this$props2.badgePosition,
          children = _this$props2.children,
          content = _this$props2.content,
          timestamp = _this$props2.timestamp,
          reactionGroup = _this$props2.reactionGroup,
          reactionGroupPosition = _this$props2.reactionGroupPosition;
      var childrenPropExists = childrenExist(children);
      var className = childrenPropExists ? cx(classes.root, classes.content) : classes.root;
      var badgeElement = Label.create(badge, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.badge,
            styles: styles.badge
          };
        }
      });
      var reactionGroupElement = Reaction.Group.create(reactionGroup, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.reactionGroup,
            styles: styles.reactionGroup
          };
        }
      });
      var actionMenuElement = this.renderActionMenu(actionMenu, styles);
      var authorElement = Text.create(author, {
        defaultProps: function defaultProps() {
          return {
            size: 'small',
            styles: styles.author,
            className: ChatMessage.slotClassNames.author
          };
        }
      });
      var timestampElement = Text.create(timestamp, {
        defaultProps: function defaultProps() {
          return {
            size: 'small',
            styles: styles.timestamp,
            timestamp: true,
            className: ChatMessage.slotClassNames.timestamp
          };
        }
      });
      var messageContent = Box.create(content, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.content,
            styles: styles.content
          };
        }
      });
      return React.createElement(Ref, {
        innerRef: this.handleMessageRef
      }, React.createElement(ElementType, _extends({
        onBlur: this.handleBlur,
        onFocus: this.handleFocus,
        onMouseEnter: this.handleMouseEnter,
        className: className
      }, accessibility.attributes.root, unhandledProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.root, unhandledProps), rtlTextContainer.getAttributes({
        forElements: [children]
      })), childrenPropExists ? children : React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, authorElement, timestampElement, reactionGroupPosition === 'start' && reactionGroupElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement)));
    }
  }]);

  return ChatMessage;
}(UIComponent);

_defineProperty(ChatMessage, "className", 'ui-chat__message');

_defineProperty(ChatMessage, "create", void 0);

_defineProperty(ChatMessage, "slotClassNames", void 0);

_defineProperty(ChatMessage, "displayName", 'ChatMessage');

_defineProperty(ChatMessage, "__isChatMessage", true);

_defineProperty(ChatMessage, "isTypeOfElement", function (element) {
  return _get(element, "type.__isChatMessage");
});

_defineProperty(ChatMessage, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  content: 'shorthand'
}), {
  actionMenu: customPropTypes.itemShorthand,
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
  author: customPropTypes.itemShorthand,
  badge: customPropTypes.itemShorthand,
  badgePosition: PropTypes.oneOf(['start', 'end']),
  mine: PropTypes.bool,
  timestamp: customPropTypes.itemShorthand,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onMouseEnter: PropTypes.func,
  positionActionMenu: PropTypes.bool,
  reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
  unstable_overflow: PropTypes.bool
}));

_defineProperty(ChatMessage, "defaultProps", {
  accessibility: chatMessageBehavior,
  as: 'div',
  badgePosition: 'end',
  positionActionMenu: true,
  reactionGroupPosition: 'start'
});

ChatMessage.create = createShorthandFactory({
  Component: ChatMessage,
  mappedProp: 'content'
});
ChatMessage.slotClassNames = {
  actionMenu: "".concat(ChatMessage.className, "__actions"),
  author: "".concat(ChatMessage.className, "__author"),
  timestamp: "".concat(ChatMessage.className, "__timestamp"),
  badge: "".concat(ChatMessage.className, "__badge"),
  content: "".concat(ChatMessage.className, "__content"),
  reactionGroup: "".concat(ChatMessage.className, "__reactions")
  /**
   * A ChatMessage represents a single message in chat.
   */

};
export default withSafeTypeForAs(ChatMessage);