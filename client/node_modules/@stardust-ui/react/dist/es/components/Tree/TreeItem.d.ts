import { Accessibility } from '@stardust-ui/accessibility';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { TreeTitleProps } from './TreeTitle';
import { UIComponent, UIComponentProps, ChildrenComponentProps, ShorthandFactory } from '../../lib';
import { ComponentEventHandler, WithAsProp, ShorthandRenderFunction, ShorthandValue, ShorthandCollection } from '../../types';
import { ReactAccessibilityBehavior } from '../../lib/accessibility/reactTypes';
export interface TreeItemSlotClassNames {
    title: string;
    subtree: string;
}
export interface TreeItemProps extends UIComponentProps, ChildrenComponentProps {
    /** Accessibility behavior if overridden by the user. */
    accessibility?: Accessibility;
    /** Id needed to identify this item inside the Tree. */
    id: string;
    /** The index of the item among its siblings. Count starts at 1. */
    index?: number;
    /** Array of props for sub tree. */
    items?: ShorthandCollection<TreeItemProps>;
    /** Ref for the item DOM element. */
    contentRef?: React.Ref<HTMLElement>;
    /** Level of the tree/subtree that contains this item. */
    level?: number;
    /** Called when a tree title is clicked. */
    onTitleClick?: ComponentEventHandler<TreeItemProps>;
    /** Called when the item's first child is about to be focused. */
    onFocusFirstChild?: ComponentEventHandler<TreeItemProps>;
    /** Called when the item's siblings are about to be expanded. */
    onSiblingsExpand?: ComponentEventHandler<TreeItemProps>;
    /** Called when the item's parent is about to be focused. */
    onFocusParent?: ComponentEventHandler<TreeItemProps>;
    /** Whether or not the item is in the open state. Only makes sense if item has children items. */
    open?: boolean;
    /** The id of the parent tree item, if any. */
    parent?: ShorthandValue<TreeItemProps>;
    /** Array with the ids of the tree item's siblings, if any. */
    siblings?: ShorthandCollection<TreeItemProps>;
    /**
     * A custom render iterator for rendering each tree title.
     * The default component, props, and children are available for each tree title.
     *
     * @param {React.ReactType} Component - The computed component for this slot.
     * @param {object} props - The computed props for this slot.
     * @param {ReactNode|ReactNodeArray} children - The computed children for this slot.
     */
    renderItemTitle?: ShorthandRenderFunction<TreeTitleProps>;
    /** Properties for TreeTitle. */
    title?: ShorthandValue<TreeTitleProps>;
}
export interface TreeItemState {
    treeSize: number;
    hasSubtree: boolean;
}
declare class TreeItem extends UIComponent<WithAsProp<TreeItemProps>, TreeItemState> {
    static create: ShorthandFactory<TreeItemProps>;
    static displayName: string;
    static className: string;
    static slotClassNames: TreeItemSlotClassNames;
    static propTypes: {
        contentRef: PropTypes.Requireable<object>;
        id: PropTypes.Validator<string>;
        index: PropTypes.Requireable<number>;
        items: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        level: PropTypes.Requireable<number>;
        onTitleClick: PropTypes.Requireable<(...args: any[]) => any>;
        onFocusFirstChild: PropTypes.Requireable<(...args: any[]) => any>;
        onFocusParent: PropTypes.Requireable<(...args: any[]) => any>;
        onSiblingsExpand: PropTypes.Requireable<(...args: any[]) => any>;
        open: PropTypes.Requireable<boolean>;
        parent: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        renderItemTitle: PropTypes.Requireable<(...args: any[]) => any>;
        siblings: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        title: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        styles: PropTypes.Requireable<object>;
        variables: PropTypes.Requireable<object>;
        design: PropTypes.Requireable<PropTypes.InferProps<{
            position: PropTypes.Requireable<string>;
            display: PropTypes.Requireable<string>;
            top: PropTypes.Requireable<string>;
            right: PropTypes.Requireable<string>;
            bottom: PropTypes.Requireable<string>;
            left: PropTypes.Requireable<string>;
            padding: PropTypes.Requireable<string>;
            paddingTop: PropTypes.Requireable<string>;
            paddingRight: PropTypes.Requireable<string>;
            paddingBottom: PropTypes.Requireable<string>;
            paddingLeft: PropTypes.Requireable<string>;
            margin: PropTypes.Requireable<string>;
            marginTop: PropTypes.Requireable<string>;
            marginRight: PropTypes.Requireable<string>;
            marginBottom: PropTypes.Requireable<string>;
            marginLeft: PropTypes.Requireable<string>;
            width: PropTypes.Requireable<string>;
            height: PropTypes.Requireable<string>;
            minWidth: PropTypes.Requireable<string>;
            maxWidth: PropTypes.Requireable<string>;
            minHeight: PropTypes.Requireable<string>;
            maxHeight: PropTypes.Requireable<string>;
        }>>;
        content: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        color: PropTypes.Requireable<string>;
        className: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        as: PropTypes.Requireable<PropTypes.ReactComponentLike>;
        animation: PropTypes.Requireable<any>;
        accessibility: PropTypes.Requireable<object>;
    };
    static defaultProps: {
        as: string;
        accessibility: Accessibility<any>;
    };
    state: {
        hasSubtree: boolean;
        treeSize: number;
    };
    static getDerivedStateFromProps(props: TreeItemProps): {
        hasSubtree: boolean;
        treeSize: number;
    };
    actionHandlers: {
        performClick: (e: any) => void;
        focusParent: (e: any) => void;
        collapse: (e: any) => void;
        expand: (e: any) => void;
        focusFirstChild: (e: any) => void;
        expandSiblings: (e: any) => void;
    };
    handleTitleClick: (e: any) => void;
    handleTitleOverrides: (predefinedProps: TreeTitleProps) => {
        onClick: (e: any, titleProps: any) => void;
    };
    renderContent(accessibility: ReactAccessibilityBehavior): React.ReactElement<any, string | ((props: any) => React.ReactElement<any, string | any | (new (props: any) => React.Component<any, any, any>)>) | (new (props: any) => React.Component<any, any, any>)>;
    renderComponent({ ElementType, accessibility, classes, unhandledProps }: {
        ElementType: any;
        accessibility: any;
        classes: any;
        unhandledProps: any;
    }): JSX.Element;
}
declare const _default: {
    <Tag>(x: {
        as: Tag;
    } & TreeItemProps & {
        [K: string]: any;
    }): JSX.Element;
    (x: {
        accessibility?: Accessibility<any>;
        id: string;
        index?: number;
        items?: ShorthandValue<TreeItemProps & {
            kind?: never;
        }>[];
        contentRef?: React.Ref<HTMLElement>;
        level?: number;
        onTitleClick?: ComponentEventHandler<TreeItemProps>;
        onFocusFirstChild?: ComponentEventHandler<TreeItemProps>;
        onSiblingsExpand?: ComponentEventHandler<TreeItemProps>;
        onFocusParent?: ComponentEventHandler<TreeItemProps>;
        open?: boolean;
        parent?: ShorthandValue<TreeItemProps>;
        siblings?: ShorthandValue<TreeItemProps & {
            kind?: never;
        }>[];
        renderItemTitle?: ShorthandRenderFunction<TreeTitleProps>;
        title?: ShorthandValue<TreeTitleProps>;
        className?: string;
        design?: import("../..").ComponentDesign;
        styles?: import("../..").ComponentSlotStyle<any, any>;
        variables?: any;
        animation?: import("../..").AnimationProp;
        children?: React.ReactNode;
        ref?: React.LegacyRef<HTMLLIElement>;
        key?: string | number;
        value?: string | number | string[];
        defaultChecked?: boolean;
        defaultValue?: string | string[];
        suppressContentEditableWarning?: boolean;
        suppressHydrationWarning?: boolean;
        accessKey?: string;
        contentEditable?: boolean;
        contextMenu?: string;
        dir?: string;
        draggable?: boolean;
        hidden?: boolean;
        lang?: string;
        placeholder?: string;
        slot?: string;
        spellCheck?: boolean;
        style?: React.CSSProperties;
        tabIndex?: number;
        inputMode?: string;
        is?: string;
        radioGroup?: string;
        role?: string;
        about?: string;
        datatype?: string;
        inlist?: any;
        prefix?: string;
        property?: string;
        resource?: string;
        typeof?: string;
        vocab?: string;
        autoCapitalize?: string;
        autoCorrect?: string;
        autoSave?: string;
        color?: string;
        itemProp?: string;
        itemScope?: boolean;
        itemType?: string;
        itemID?: string;
        itemRef?: string;
        results?: number;
        security?: string;
        unselectable?: "on" | "off";
        'aria-activedescendant'?: string;
        'aria-atomic'?: boolean | "false" | "true";
        'aria-autocomplete'?: "none" | "both" | "inline" | "list";
        'aria-busy'?: boolean | "false" | "true";
        'aria-checked'?: boolean | "mixed" | "false" | "true";
        'aria-colcount'?: number;
        'aria-colindex'?: number;
        'aria-colspan'?: number;
        'aria-controls'?: string;
        'aria-current'?: boolean | "time" | "page" | "false" | "true" | "step" | "location" | "date";
        'aria-describedby'?: string;
        'aria-details'?: string;
        'aria-disabled'?: boolean | "false" | "true";
        'aria-dropeffect'?: "link" | "none" | "copy" | "move" | "execute" | "popup";
        'aria-errormessage'?: string;
        'aria-expanded'?: boolean | "false" | "true";
        'aria-flowto'?: string;
        'aria-grabbed'?: boolean | "false" | "true";
        'aria-haspopup'?: boolean | "dialog" | "menu" | "grid" | "listbox" | "false" | "true" | "tree";
        'aria-hidden'?: boolean | "false" | "true";
        'aria-invalid'?: boolean | "false" | "true" | "grammar" | "spelling";
        'aria-keyshortcuts'?: string;
        'aria-label'?: string;
        'aria-labelledby'?: string;
        'aria-level'?: number;
        'aria-live'?: "off" | "assertive" | "polite";
        'aria-modal'?: boolean | "false" | "true";
        'aria-multiline'?: boolean | "false" | "true";
        'aria-multiselectable'?: boolean | "false" | "true";
        'aria-orientation'?: "horizontal" | "vertical";
        'aria-owns'?: string;
        'aria-placeholder'?: string;
        'aria-posinset'?: number;
        'aria-pressed'?: boolean | "mixed" | "false" | "true";
        'aria-readonly'?: boolean | "false" | "true";
        'aria-relevant'?: "all" | "text" | "additions" | "additions text" | "removals";
        'aria-required'?: boolean | "false" | "true";
        'aria-roledescription'?: string;
        'aria-rowcount'?: number;
        'aria-rowindex'?: number;
        'aria-rowspan'?: number;
        'aria-selected'?: boolean | "false" | "true";
        'aria-setsize'?: number;
        'aria-sort'?: "none" | "ascending" | "descending" | "other";
        'aria-valuemax'?: number;
        'aria-valuemin'?: number;
        'aria-valuenow'?: number;
        'aria-valuetext'?: string;
        dangerouslySetInnerHTML?: {
            __html: string;
        };
        onCopy?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onCopyCapture?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onCut?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onCutCapture?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onPaste?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onPasteCapture?: (event: React.ClipboardEvent<HTMLLIElement>) => void;
        onCompositionEnd?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onCompositionEndCapture?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onCompositionStart?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onCompositionStartCapture?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onCompositionUpdate?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onCompositionUpdateCapture?: (event: React.CompositionEvent<HTMLLIElement>) => void;
        onFocus?: (event: React.FocusEvent<HTMLLIElement>) => void;
        onFocusCapture?: (event: React.FocusEvent<HTMLLIElement>) => void;
        onBlur?: (event: React.FocusEvent<HTMLLIElement>) => void;
        onBlurCapture?: (event: React.FocusEvent<HTMLLIElement>) => void;
        onChange?: (event: React.FormEvent<HTMLLIElement>) => void;
        onChangeCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onBeforeInput?: (event: React.FormEvent<HTMLLIElement>) => void;
        onBeforeInputCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onInput?: (event: React.FormEvent<HTMLLIElement>) => void;
        onInputCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onReset?: (event: React.FormEvent<HTMLLIElement>) => void;
        onResetCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onSubmit?: (event: React.FormEvent<HTMLLIElement>) => void;
        onSubmitCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onInvalid?: (event: React.FormEvent<HTMLLIElement>) => void;
        onInvalidCapture?: (event: React.FormEvent<HTMLLIElement>) => void;
        onLoad?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onError?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onErrorCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onKeyDown?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onKeyDownCapture?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onKeyPress?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onKeyPressCapture?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onKeyUp?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onKeyUpCapture?: (event: React.KeyboardEvent<HTMLLIElement>) => void;
        onAbort?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onAbortCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onCanPlay?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onCanPlayCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onCanPlayThrough?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onCanPlayThroughCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onDurationChange?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onDurationChangeCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEmptied?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEmptiedCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEncrypted?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEncryptedCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEnded?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onEndedCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadedData?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadedDataCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadedMetadata?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadedMetadataCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadStart?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onLoadStartCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPause?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPauseCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPlay?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPlayCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPlaying?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onPlayingCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onProgress?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onProgressCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onRateChange?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onRateChangeCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSeeked?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSeekedCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSeeking?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSeekingCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onStalled?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onStalledCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSuspend?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSuspendCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onTimeUpdate?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onTimeUpdateCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onVolumeChange?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onVolumeChangeCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onWaiting?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onWaitingCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onClick?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onClickCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onContextMenu?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onContextMenuCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onDoubleClick?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onDoubleClickCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onDrag?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragEnd?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragEndCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragEnter?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragEnterCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragExit?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragExitCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragLeave?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragLeaveCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragOver?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragOverCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragStart?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDragStartCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDrop?: (event: React.DragEvent<HTMLLIElement>) => void;
        onDropCapture?: (event: React.DragEvent<HTMLLIElement>) => void;
        onMouseDown?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseDownCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseEnter?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseLeave?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseMove?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseMoveCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseOut?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseOutCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseOver?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseOverCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseUp?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onMouseUpCapture?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;
        onSelect?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onSelectCapture?: (event: React.SyntheticEvent<HTMLLIElement, Event>) => void;
        onTouchCancel?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchCancelCapture?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchEnd?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchEndCapture?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchMove?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchMoveCapture?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchStart?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onTouchStartCapture?: (event: React.TouchEvent<HTMLLIElement>) => void;
        onPointerDown?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerDownCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerMove?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerMoveCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerUp?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerUpCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerCancel?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerCancelCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerEnter?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerEnterCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerLeave?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerLeaveCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerOver?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerOverCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerOut?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onPointerOutCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onGotPointerCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onGotPointerCaptureCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onLostPointerCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onLostPointerCaptureCapture?: (event: React.PointerEvent<HTMLLIElement>) => void;
        onScroll?: (event: React.UIEvent<HTMLLIElement>) => void;
        onScrollCapture?: (event: React.UIEvent<HTMLLIElement>) => void;
        onWheel?: (event: React.WheelEvent<HTMLLIElement>) => void;
        onWheelCapture?: (event: React.WheelEvent<HTMLLIElement>) => void;
        onAnimationStart?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onAnimationStartCapture?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onAnimationEnd?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onAnimationEndCapture?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onAnimationIteration?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onAnimationIterationCapture?: (event: React.AnimationEvent<HTMLLIElement>) => void;
        onTransitionEnd?: (event: React.TransitionEvent<HTMLLIElement>) => void;
        onTransitionEndCapture?: (event: React.TransitionEvent<HTMLLIElement>) => void;
    }): JSX.Element;
} & {
    contextType: any;
    displayName: string;
    getDerivedStateFromProps: typeof TreeItem.getDerivedStateFromProps;
    className: string;
    handledProps: string[];
    unhandledProps: string[];
    create: ShorthandFactory<TreeItemProps>;
    _handledPropsCache: string[];
    slotClassNames: TreeItemSlotClassNames;
};
/**
 * A TreeItem renders an item of a Tree.
 *
 * @accessibility
 * Implements [ARIA TreeView](https://www.w3.org/TR/wai-aria-practices-1.1/#TreeView) design pattern.
 */
export default _default;
