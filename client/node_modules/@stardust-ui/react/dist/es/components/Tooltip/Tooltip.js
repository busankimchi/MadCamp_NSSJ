import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _invoke from "lodash/invoke";
import { toRefObject, Ref } from '@stardust-ui/react-component-ref';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { applyAccessibilityKeyHandlers, childrenExist, AutoControlledComponent, commonPropTypes, isFromKeyboard, setWhatInputSource, getOrGenerateIdFromShorthand, createShorthandFactory } from '../../lib';
import { ALIGNMENTS, POSITIONS, Popper } from '../../lib/positioner';
import TooltipContent from './TooltipContent';
import { tooltipBehavior } from '@stardust-ui/accessibility';
import PortalInner from '../Portal/PortalInner';

/**
 * A Tooltip displays additional non-modal information on top of its target element.
 * Tooltip doesn't receive focus and cannot contain focusable elements.
 *
 * @accessibility
 * Implements [ARIA Tooltip](https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip) design pattern.
 */
var Tooltip =
/*#__PURE__*/
function (_AutoControlledCompon) {
  _inherits(Tooltip, _AutoControlledCompon);

  function Tooltip() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Tooltip)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "pointerTargetRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "triggerRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "contentRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "closeTimeoutId", void 0);

    _defineProperty(_assertThisInitialized(_this), "actionHandlers", {
      close: function close(e) {
        _this.setTooltipOpen(false, e);

        e.stopPropagation();
        e.preventDefault();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getContentProps", function (predefinedProps) {
      var contentHandlerProps = {};

      contentHandlerProps.onMouseEnter = function (e, contentProps) {
        _this.setTooltipOpen(true, e);

        _invoke(predefinedProps, 'onMouseEnter', e, contentProps);
      };

      contentHandlerProps.onMouseLeave = function (e, contentProps) {
        _this.setTooltipOpen(false, e);

        _invoke(predefinedProps, 'onMouseLeave', e, contentProps);
      };

      return contentHandlerProps;
    });

    _defineProperty(_assertThisInitialized(_this), "shouldStayOpen", function (e) {
      return _invoke(e, 'currentTarget.contains', e.relatedTarget) || _invoke(_this.contentRef.current, 'contains', e.relatedTarget);
    });

    _defineProperty(_assertThisInitialized(_this), "renderPopperChildren", function (tooltipPositionClasses, rtl, accessibility, _ref) {
      var placement = _ref.placement;
      var _this$props = _this.props,
          content = _this$props.content,
          pointing = _this$props.pointing;
      var tooltipContentAttributes = Object.assign({}, rtl && {
        dir: 'rtl'
      }, accessibility.attributes.tooltip, accessibility.keyHandlers.tooltip, {
        className: tooltipPositionClasses
      }, _this.getContentProps());
      var tooltipContent = Tooltip.Content.create(content, {
        defaultProps: function defaultProps() {
          return Object.assign({}, tooltipContentAttributes, {
            open: _this.state.open,
            placement: placement,
            pointing: pointing,
            pointerRef: _this.pointerTargetRef
          });
        },
        overrideProps: _this.getContentProps
      });
      return React.createElement(Ref, {
        innerRef: _this.contentRef
      }, tooltipContent);
    });

    _defineProperty(_assertThisInitialized(_this), "scheduleTooltipClose", function (e) {
      var mouseLeaveDelay = _this.props.mouseLeaveDelay;
      _this.closeTimeoutId = setTimeout(function () {
        _this.trySetOpen(false, e);
      }, mouseLeaveDelay);
    });

    _defineProperty(_assertThisInitialized(_this), "close", function (e, onClose) {
      if (_this.state.open) {
        _this.trySetOpen(false, e);

        onClose && onClose();
        e.stopPropagation();
      }
    });

    return _this;
  }

  _createClass(Tooltip, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        open: false
      };
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var classes = _ref2.classes,
          rtl = _ref2.rtl,
          accessibility = _ref2.accessibility;
      var _this$props2 = this.props,
          mountNode = _this$props2.mountNode,
          children = _this$props2.children,
          trigger = _this$props2.trigger;
      var tooltipContent = this.renderTooltipContent(classes.content, rtl, accessibility);
      var triggerNode = childrenExist(children) ? children : trigger;
      var triggerElement = triggerNode && React.Children.only(triggerNode);
      var triggerProps = this.getTriggerProps(triggerElement);
      return React.createElement(React.Fragment, null, triggerElement && React.createElement(Ref, {
        innerRef: this.triggerRef
      }, React.cloneElement(triggerElement, Object.assign({}, accessibility.attributes.trigger, triggerProps, applyAccessibilityKeyHandlers(accessibility.keyHandlers.trigger, triggerProps)))), React.createElement(PortalInner, {
        mountNode: mountNode
      }, tooltipContent));
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps(triggerElement) {
      var _this2 = this;

      var triggerProps = {};

      triggerProps.onFocus = function (e) {
        if (isFromKeyboard()) {
          _this2.trySetOpen(true, e);
        }

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _invoke.apply(void 0, [triggerElement, 'props.onFocus', e].concat(args));
      };

      triggerProps.onBlur = function (e) {
        if (!_this2.shouldStayOpen(e)) {
          _this2.trySetOpen(false, e);
        }

        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        _invoke.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
      };

      triggerProps.onMouseEnter = function (e) {
        _this2.setTooltipOpen(true, e);

        setWhatInputSource('mouse');

        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        _invoke.apply(void 0, [triggerElement, 'props.onMouseEnter', e].concat(args));
      };

      triggerProps.onMouseLeave = function (e) {
        _this2.setTooltipOpen(false, e);

        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }

        _invoke.apply(void 0, [triggerElement, 'props.onMouseLeave', e].concat(args));
      };

      return triggerProps;
    }
  }, {
    key: "renderTooltipContent",
    value: function renderTooltipContent(tooltipPositionClasses, rtl, accessibility) {
      var _this$props3 = this.props,
          align = _this$props3.align,
          position = _this$props3.position,
          target = _this$props3.target,
          offset = _this$props3.offset;
      var open = this.state.open;
      return React.createElement(Popper, {
        pointerTargetRef: this.pointerTargetRef,
        align: align,
        offset: offset,
        position: position,
        enabled: open,
        rtl: rtl,
        targetRef: target ? toRefObject(target) : this.triggerRef,
        children: this.renderPopperChildren.bind(this, tooltipPositionClasses, rtl, accessibility)
      });
    }
  }, {
    key: "trySetOpen",
    value: function trySetOpen(newValue, eventArgs) {
      this.setState({
        open: newValue
      });

      _invoke(this.props, 'onOpenChange', eventArgs, Object.assign({}, this.props, {
        open: newValue
      }));
    }
  }, {
    key: "setTooltipOpen",
    value: function setTooltipOpen(newOpen, e) {
      clearTimeout(this.closeTimeoutId);
      newOpen ? this.trySetOpen(true, e) : this.scheduleTooltipClose(e);
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(props, state) {
      return {
        contentId: getOrGenerateIdFromShorthand('tooltip-content-', props.content, state.contentId)
      };
    }
  }]);

  return Tooltip;
}(AutoControlledComponent);

_defineProperty(Tooltip, "displayName", 'Tooltip');

_defineProperty(Tooltip, "className", 'ui-tooltip');

_defineProperty(Tooltip, "slotClassNames", {
  content: "".concat(Tooltip.className, "__content")
});

_defineProperty(Tooltip, "Content", TooltipContent);

_defineProperty(Tooltip, "propTypes", Object.assign({}, commonPropTypes.createCommon({
  animated: false,
  as: false,
  content: false
}), {
  align: PropTypes.oneOf(ALIGNMENTS),
  defaultOpen: PropTypes.bool,
  inline: PropTypes.bool,
  mountNode: customPropTypes.domNode,
  mouseLeaveDelay: PropTypes.number,
  offset: PropTypes.string,
  open: PropTypes.bool,
  onOpenChange: PropTypes.func,
  pointing: PropTypes.bool,
  position: PropTypes.oneOf(POSITIONS),
  target: customPropTypes.domNode,
  trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.element]),
  content: customPropTypes.shorthandAllowingChildren
}));

_defineProperty(Tooltip, "defaultProps", {
  align: 'center',
  position: 'above',
  mouseLeaveDelay: 10,
  pointing: true,
  accessibility: tooltipBehavior
});

_defineProperty(Tooltip, "autoControlledProps", ['open']);

_defineProperty(Tooltip, "create", void 0);

export { Tooltip as default };
Tooltip.create = createShorthandFactory({
  Component: Tooltip,
  mappedProp: 'content'
});