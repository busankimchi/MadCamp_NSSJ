import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _debounce from "lodash/debounce";
import _invoke from "lodash/invoke";
import _forEachRight from "lodash/forEachRight";
import _get from "lodash/get";
import _map from "lodash/map";
import { toolbarBehavior, toggleButtonBehavior, IS_FOCUSABLE_ATTRIBUTE } from '@stardust-ui/accessibility';
import * as React from 'react';
import * as customPropTypes from '@stardust-ui/react-proptypes';
import * as PropTypes from 'prop-types';
import { Ref, toRefObject } from '@stardust-ui/react-component-ref';
import { EventListener } from '@stardust-ui/react-component-event-listener';
import { childrenExist, createShorthandFactory, UIComponent, commonPropTypes } from '../../lib';
import { mergeComponentVariables } from '../../lib/mergeThemes';
import { withSafeTypeForAs } from '../../types';
import ToolbarCustomItem from './ToolbarCustomItem';
import ToolbarDivider from './ToolbarDivider';
import ToolbarItem from './ToolbarItem';
import ToolbarMenu from './ToolbarMenu';
import ToolbarMenuDivider from './ToolbarMenuDivider';
import ToolbarMenuItem from './ToolbarMenuItem';
import ToolbarMenuRadioGroup from './ToolbarMenuRadioGroup';
import ToolbarRadioGroup from './ToolbarRadioGroup';
var WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';

var Toolbar =
/*#__PURE__*/
function (_UIComponent) {
  _inherits(Toolbar, _UIComponent);

  function Toolbar() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Toolbar);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Toolbar)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "overflowContainerRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "overflowItemRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "offsetMeasureRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "lastVisibleItemIndex", void 0);

    _defineProperty(_assertThisInitialized(_this), "animationFrameId", void 0);

    _defineProperty(_assertThisInitialized(_this), "rtl", void 0);

    _defineProperty(_assertThisInitialized(_this), "handleItemOverrides", function (variables) {
      return function (predefinedProps) {
        return {
          variables: mergeComponentVariables(variables, predefinedProps.variables)
        };
      };
    });

    _defineProperty(_assertThisInitialized(_this), "hideOverflowItems", function () {
      var $overflowContainer = _this.overflowContainerRef.current;
      var $overflowItem = _this.overflowItemRef.current;
      var $offsetMeasure = _this.offsetMeasureRef.current;

      if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {
        return;
      } // workaround: when resizing window with popup opened the container contents scroll for some reason


      if (_this.rtl) {
        $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);
      } else {
        $overflowContainer.scrollTo(0, 0);
      }

      var $items = $overflowContainer.children;
      var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();
      var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();
      var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset
      // Overflow menu is absolutely positioned relative to root slot
      // If there is padding set on the root slot boundingClientRect computations use inner content box,
      // but absolute position is relative to root slot's PADDING box.
      // We compute absolute positioning offset
      // By measuring position of an offsetMeasure element absolutely positioned to 0,0.
      // TODO: replace by getComputedStyle('padding')

      var absolutePositioningOffset = {
        horizontal: _this.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,
        vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top
      };
      var isOverflowing = false;
      var $lastVisibleItem;
      var lastVisibleItemRect; // check all items from the last one back

      _forEachRight($items, function ($item, i) {
        if ($item === $overflowItem) {
          return true;
        }

        var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it

        if (_this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {
          isOverflowing = true; // console.log('Overflow', i, {
          //   item: [itemBoundingRect.left, itemBoundingRect.right],
          //   crop: [
          //     overflowContainerBoundingRect.left,
          //     overflowContainerBoundingRect.right,
          //     overflowContainerBoundingRect.width,
          //   ],
          //   container: $overflowContainer,
          // })

          _this.hide($item);

          return true;
        } // if there is an overflow, check collision of remaining items with eventual overflow position


        if (isOverflowing && !$lastVisibleItem && _this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {
          _this.hide($item);

          return true;
        } // Remember the last visible item


        if (!$lastVisibleItem) {
          $lastVisibleItem = $item;
          lastVisibleItemRect = itemBoundingRect;
          _this.lastVisibleItemIndex = i;
        }

        return _this.show($item); // exit the loop when first visible item is found
      }); // if there is an overflow,  position and show overflow item, otherwise hide it


      if (isOverflowing || _this.props.overflowOpen) {
        $overflowItem.style.position = 'absolute';

        _this.setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);

        _this.show($overflowItem);
      } else {
        _this.lastVisibleItemIndex = _this.props.items.length - 1;

        _this.hide($overflowItem);
      }

      _invoke(_this.props, 'onOverflow', _this.lastVisibleItemIndex + 1);
    });

    _defineProperty(_assertThisInitialized(_this), "getOverflowItems", function () {
      // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))
      return _this.props.getOverflowItems ? _this.props.getOverflowItems(_this.lastVisibleItemIndex + 1) : _this.props.items.slice(_this.lastVisibleItemIndex + 1);
    });

    _defineProperty(_assertThisInitialized(_this), "getVisibleItems", function () {
      // console.log('allItems()', this.props.items)
      var end = _this.props.overflowOpen ? _this.lastVisibleItemIndex + 1 : _this.props.items.length; // console.log('getVisibleItems()', this.props.items.slice(0, end))

      return _this.props.items.slice(0, end);
    });

    _defineProperty(_assertThisInitialized(_this), "handleWindowResize", _debounce(function (e) {
      _this.hideOverflowItems();

      if (_this.props.overflowOpen) {
        _invoke(_this.props, 'onOverflowOpenChange', e, Object.assign({}, _this.props, {
          overflowOpen: false
        }));
      }
    }, 16));

    return _this;
  }

  _createClass(Toolbar, [{
    key: "renderItems",
    value: function renderItems(items, variables) {
      var itemOverridesFn = this.handleItemOverrides(variables);
      return _map(items, function (item) {
        var kind = _get(item, 'kind', 'item');

        switch (kind) {
          case 'divider':
            return ToolbarDivider.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'group':
            return ToolbarRadioGroup.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'toggle':
            return ToolbarItem.create(item, {
              defaultProps: function defaultProps() {
                return {
                  accessibility: toggleButtonBehavior
                };
              },
              overrideProps: itemOverridesFn
            });

          case 'custom':
            return ToolbarCustomItem.create(item, {
              overrideProps: itemOverridesFn
            });

          default:
            return ToolbarItem.create(item, {
              overrideProps: itemOverridesFn
            });
        }
      });
    }
  }, {
    key: "hide",
    value: function hide(el) {
      if (el.style.visibility === 'hidden') {
        return;
      }

      el.style.visibility = 'hidden';
      var wasFocusable = el.getAttribute(IS_FOCUSABLE_ATTRIBUTE);

      if (wasFocusable) {
        el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);
      }

      el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, 'false');
    }
  }, {
    key: "show",
    value: function show(el) {
      if (el.style.visibility !== 'hidden') {
        return false;
      }

      el.style.visibility = null;
      var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);

      if (wasFocusable) {
        el.setAttribute(IS_FOCUSABLE_ATTRIBUTE, wasFocusable);
        el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);
      } else {
        el.removeAttribute(IS_FOCUSABLE_ATTRIBUTE);
      }

      return true;
    }
    /**
     * Checks if `item` overflows a `container`.
     * TODO: check and fix all margin combination
     */

  }, {
    key: "isItemOverflowing",
    value: function isItemOverflowing(itemBoundingRect, containerBoundingRect) {
      return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;
    }
    /**
     * Checks if `item` would collide with eventual position of `overflowItem`.
     */

  }, {
    key: "wouldItemCollide",
    value: function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {
      var actualWindow = this.context.target.defaultView;
      var wouldCollide;

      if (this.rtl) {
        var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;
        wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {
        //   wouldCollide,
        //   'itemBoundingRect.left': itemBoundingRect.left,
        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
        //   itemRightMargin: itemLeftMargin,
        //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,
        //   'overflowContainerBoundingRect.left': containerBoundingRect.left,
        // })
      } else {
        var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;
        wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {
        //   wouldCollide,
        //   'itemBoundingRect.right': itemBoundingRect.right,
        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
        //   itemRightMargin,
        //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,
        //   'overflowContainerBoundingRect.right': containerBoundingRect.right,
        // })
      }

      return wouldCollide;
    }
    /**
     * Positions overflowItem next to lastVisible item
     * TODO: consider overflowItem margin
     */

  }, {
    key: "setOverflowPosition",
    value: function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {
      var actualWindow = this.context.target.defaultView;

      if ($lastVisibleItem) {
        if (this.rtl) {
          var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;
          $overflowItem.style.right = "".concat(containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal, "px");
        } else {
          var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;
          $overflowItem.style.left = "".concat(lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal, "px");
        }
      } else {
        // there is no last visible item -> position the overflow as the first item
        this.lastVisibleItemIndex = -1;

        if (this.rtl) {
          $overflowItem.style.right = "".concat(absolutePositioningOffset.horizontal, "px");
        } else {
          $overflowItem.style.left = "".concat(absolutePositioningOffset.horizontal, "px");
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.animationFrameId !== undefined) {
        this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = undefined;
      }
    }
  }, {
    key: "afterComponentRendered",
    value: function afterComponentRendered() {
      var _this2 = this;

      var actualWindow = this.context.target.defaultView;

      if (this.animationFrameId !== undefined) {
        actualWindow.cancelAnimationFrame(this.animationFrameId);
      } // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary


      this.animationFrameId = actualWindow.requestAnimationFrame(function () {
        _this2.hideOverflowItems();
      });
    }
  }, {
    key: "renderOverflowItem",
    value: function renderOverflowItem(overflowItem) {
      var _this3 = this;

      return React.createElement(Ref, {
        innerRef: this.overflowItemRef
      }, ToolbarItem.create(overflowItem, {
        defaultProps: function defaultProps() {
          return {
            icon: {
              name: 'more',
              outline: true
            }
          };
        },
        overrideProps: {
          menu: this.props.overflowOpen ? this.getOverflowItems() : [],
          menuOpen: this.props.overflowOpen,
          onMenuOpenChange: function onMenuOpenChange(e, _ref) {
            var menuOpen = _ref.menuOpen;

            _invoke(_this3.props, 'onOverflowOpenChange', e, Object.assign({}, _this3.props, {
              overflowOpen: menuOpen
            }));
          }
        }
      }));
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var accessibility = _ref2.accessibility,
          ElementType = _ref2.ElementType,
          classes = _ref2.classes,
          styles = _ref2.styles,
          variables = _ref2.variables,
          unhandledProps = _ref2.unhandledProps,
          rtl = _ref2.rtl;
      var windowRef = toRefObject(this.context.target.defaultView);
      this.rtl = rtl;
      var _this$props = this.props,
          children = _this$props.children,
          items = _this$props.items,
          overflow = _this$props.overflow,
          overflowItem = _this$props.overflowItem;

      if (!overflow) {
        return React.createElement(ElementType, _extends({
          className: classes.root
        }, accessibility.attributes.root, unhandledProps), childrenExist(children) ? children : this.renderItems(items, variables));
      }

      return React.createElement(React.Fragment, null, React.createElement(ElementType, _extends({
        className: classes.root
      }, accessibility.attributes.root, unhandledProps), React.createElement("div", {
        className: classes.overflowContainer,
        ref: this.overflowContainerRef
      }, childrenExist(children) ? children : this.renderItems(this.getVisibleItems(), variables), this.renderOverflowItem(overflowItem)), React.createElement("div", {
        className: classes.offsetMeasure,
        ref: this.offsetMeasureRef
      })), React.createElement(EventListener, {
        listener: this.handleWindowResize,
        targetRef: windowRef,
        type: "resize"
      }));
    }
  }]);

  return Toolbar;
}(UIComponent);

_defineProperty(Toolbar, "create", void 0);

_defineProperty(Toolbar, "className", 'ui-toolbar');

_defineProperty(Toolbar, "displayName", 'Toolbar');

_defineProperty(Toolbar, "propTypes", Object.assign({}, commonPropTypes.createCommon(), {
  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),
  overflow: PropTypes.bool,
  overflowOpen: PropTypes.bool,
  overflowItem: customPropTypes.shorthandAllowingChildren,
  onOverflow: PropTypes.func,
  onOverflowOpenChange: PropTypes.func,
  getOverflowItems: PropTypes.func
}));

_defineProperty(Toolbar, "defaultProps", {
  accessibility: toolbarBehavior,
  items: [],
  overflowItem: {}
});

_defineProperty(Toolbar, "CustomItem", ToolbarCustomItem);

_defineProperty(Toolbar, "Divider", ToolbarDivider);

_defineProperty(Toolbar, "Item", ToolbarItem);

_defineProperty(Toolbar, "Menu", ToolbarMenu);

_defineProperty(Toolbar, "MenuDivider", ToolbarMenuDivider);

_defineProperty(Toolbar, "MenuItem", ToolbarMenuItem);

_defineProperty(Toolbar, "MenuRadioGroup", ToolbarMenuRadioGroup);

_defineProperty(Toolbar, "RadioGroup", ToolbarRadioGroup);

Toolbar.create = createShorthandFactory({
  Component: Toolbar,
  mappedProp: 'content'
});
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */

export default withSafeTypeForAs(Toolbar);