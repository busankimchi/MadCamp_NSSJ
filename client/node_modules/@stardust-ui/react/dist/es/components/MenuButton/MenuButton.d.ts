import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Accessibility } from '@stardust-ui/accessibility';
import { AutoControlledComponent, RenderResultConfig, StyledComponentProps } from '../../lib';
import { ShorthandValue, ComponentEventHandler, ShorthandCollection } from '../../types';
import { ShorthandFactory } from '../../lib/factories';
import { PopupProps, PopupEvents, PopupEventsArray } from '../Popup/Popup';
import { MenuProps } from '../Menu/Menu';
import { MenuItemProps } from '../Menu/MenuItem';
import { PositioningProps } from '../../lib/positioner';
export interface MenuButtonSlotClassNames {
    menu: string;
}
export interface MenuButtonProps extends StyledComponentProps<MenuButtonProps>, PositioningProps {
    /**
     * Accessibility behavior if overridden by the user.
     * @default menuButtonBehavior
     */
    accessibility?: Accessibility;
    /** Additional CSS class name(s) to apply.  */
    className?: string;
    /** Initial value for 'open'. */
    defaultOpen?: boolean;
    /** Existing document the popup should add listeners. */
    mountDocument?: Document;
    /** Existing element the popup should be bound to. */
    mountNode?: HTMLElement;
    /** Delay in ms for the mouse leave event, before the popup will be closed. */
    mouseLeaveDelay?: number;
    /** Events triggering the popup. */
    on?: PopupEvents | PopupEventsArray;
    /** Defines whether popup is displayed. */
    open?: boolean;
    /**
     * Called after user's click on a menu item.
     *
     * @param {SyntheticEvent} event - React's original SyntheticEvent.
     * @param {object} data - All props.
     */
    onMenuItemClick?: ComponentEventHandler<MenuItemProps>;
    /**
     * Event for request to change 'open' value.
     * @param {SyntheticEvent} event - React's original SyntheticEvent.
     * @param {object} data - All props and proposed value.
     */
    onOpenChange?: ComponentEventHandler<PopupProps>;
    /** A popup can show a pointer to trigger. */
    pointing?: boolean;
    /**
     * DOM element that should be used as popup's target - instead of 'trigger' element that is used by default.
     */
    target?: HTMLElement;
    /** Element to be rendered in-place where the popup is defined. */
    trigger?: JSX.Element;
    /** Whether the trigger should be tabbable */
    tabbableTrigger?: boolean;
    /** Shorthand for menu configuration */
    menu?: ShorthandValue<MenuProps> | ShorthandCollection<MenuItemProps>;
    /** Determines if the MenuButton behaves as context menu */
    contextMenu?: boolean;
}
export interface MenuButtonState {
    open: boolean;
    menuId: string;
    triggerId: string;
}
/**
 * A MenuButton displays a menu connected to trigger element.
 * @accessibility
 */
export default class MenuButton extends AutoControlledComponent<MenuButtonProps, MenuButtonState> {
    static displayName: string;
    static className: string;
    static create: ShorthandFactory<MenuButtonProps>;
    static slotClassNames: MenuButtonSlotClassNames;
    static propTypes: {
        align: PropTypes.Requireable<import("../../lib/positioner").Alignment>;
        defaultOpen: PropTypes.Requireable<boolean>;
        mountDocument: PropTypes.Requireable<object>;
        mountNode: (props: Record<string, any>, propName: string) => Error;
        mouseLeaveDelay: PropTypes.Requireable<number>;
        offset: PropTypes.Requireable<string>;
        on: PropTypes.Requireable<string | string[]>;
        open: PropTypes.Requireable<boolean>;
        onMenuItemClick: PropTypes.Requireable<(...args: any[]) => any>;
        onOpenChange: PropTypes.Requireable<(...args: any[]) => any>;
        position: PropTypes.Requireable<import("../../lib/positioner").Position>;
        target: PropTypes.Requireable<any>;
        trigger: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        tabbableTrigger: PropTypes.Requireable<boolean>;
        unstable_pinned: PropTypes.Requireable<boolean>;
        menu: PropTypes.Requireable<{}>;
        contextMenu: PropTypes.Requireable<boolean>;
        styles: PropTypes.Requireable<object>;
        variables: PropTypes.Requireable<object>;
        design: PropTypes.Requireable<PropTypes.InferProps<{
            position: PropTypes.Requireable<string>;
            display: PropTypes.Requireable<string>;
            top: PropTypes.Requireable<string>;
            right: PropTypes.Requireable<string>;
            bottom: PropTypes.Requireable<string>;
            left: PropTypes.Requireable<string>;
            padding: PropTypes.Requireable<string>;
            paddingTop: PropTypes.Requireable<string>;
            paddingRight: PropTypes.Requireable<string>;
            paddingBottom: PropTypes.Requireable<string>;
            paddingLeft: PropTypes.Requireable<string>;
            margin: PropTypes.Requireable<string>;
            marginTop: PropTypes.Requireable<string>;
            marginRight: PropTypes.Requireable<string>;
            marginBottom: PropTypes.Requireable<string>;
            marginLeft: PropTypes.Requireable<string>;
            width: PropTypes.Requireable<string>;
            height: PropTypes.Requireable<string>;
            minWidth: PropTypes.Requireable<string>;
            maxWidth: PropTypes.Requireable<string>;
            minHeight: PropTypes.Requireable<string>;
            maxHeight: PropTypes.Requireable<string>;
        }>>;
        content: (props: Record<string, any>, propName: string, componentName: string, ...args: any[]) => any;
        color: PropTypes.Requireable<string>;
        className: PropTypes.Requireable<string>;
        children: PropTypes.Requireable<PropTypes.ReactNodeLike>;
        as: PropTypes.Requireable<PropTypes.ReactComponentLike>;
        animation: PropTypes.Requireable<any>;
        accessibility: PropTypes.Requireable<object>;
    };
    static defaultProps: MenuButtonProps;
    static autoControlledProps: string[];
    static getAutoControlledStateFromProps(props: MenuButtonProps, state: MenuButtonState): Partial<MenuButtonState>;
    triggerRef: React.RefObject<HTMLElement>;
    menuRef: React.RefObject<HTMLElement>;
    actionHandlers: {
        closeMenu: () => void;
        openAndFocusFirst: (e: any) => void;
        openAndFocusLast: (e: any) => void;
    };
    closeMenu(): void;
    openAndFocus(e: React.KeyboardEvent, which: 'first' | 'last'): void;
    handleOpenChange: (e: any, { open }: PopupProps) => void;
    handleMenuOverrides: (predefinedProps?: MenuProps) => {
        onItemClick: (e: React.SyntheticEvent<Element, Event>, itemProps: MenuItemProps) => void;
    };
    renderComponent({ ElementType, classes, unhandledProps, accessibility, styles, }: RenderResultConfig<MenuButtonProps>): React.ReactNode;
}
