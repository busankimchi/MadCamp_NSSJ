import _filter from "lodash/filter";
import _isEmpty from "lodash/isEmpty";
import _isNil from "lodash/isNil";
import { FocusZoneMode } from '@stardust-ui/accessibility';
import { callable, FocusZone, FOCUSZONE_WRAP_ATTRIBUTE, getElementType, getUnhandledProps } from '@stardust-ui/react-bindings';
import cx from 'classnames';
import * as React from 'react';
import logProviderMissingWarning from './providerMissingHandler';
import getKeyDownHandlers from './getKeyDownHandlers';
import { emptyTheme, mergeComponentStyles, mergeComponentVariables } from './mergeThemes';
import createAnimationStyles from './createAnimationStyles';
import { isEnabled as isDebugEnabled } from './debug/debugEnabled';
import withDebugId from './withDebugId';
import resolveStylesAndClasses from './resolveStylesAndClasses';
var emptyBehavior = {
  attributes: {},
  keyHandlers: {}
};

var getAccessibility = function getAccessibility(displayName, props, actionHandlers, isRtlEnabled) {
  var accessibility = props.accessibility;

  if (_isNil(accessibility)) {
    return emptyBehavior;
  }

  var definition = accessibility(props);
  var keyHandlers = getKeyDownHandlers(actionHandlers, definition.keyActions, isRtlEnabled);

  if (process.env.NODE_ENV !== 'production') {
    // For the non-production builds we enable the runtime accessibility attributes validator.
    // We're adding the data-aa-class attribute which is being consumed by the validator, the
    // schema is located in @stardust-ui/ability-attributes package.
    if (definition.attributes) {
      var slotNames = Object.keys(definition.attributes);
      slotNames.forEach(function (slotName) {
        if (!definition.attributes[slotName]) {
          definition.attributes[slotName] = {};
        }

        definition.attributes[slotName]['data-aa-class'] = "".concat(displayName).concat(slotName === 'root' ? '' : "__".concat(slotName));
      });
    }
  }

  return Object.assign({}, emptyBehavior, definition, {
    keyHandlers: keyHandlers
  });
};
/**
 * This function provides compile-time type checking for the following:
 * - if FocusZone implements FocusZone interface,
 * - if FocusZone properties extend FocusZoneProps, and
 * - if the passed properties extend FocusZoneProps.
 *
 * Should the FocusZone implementation change at any time, this function should provide a compile-time guarantee
 * that the new implementation is backwards compatible with the old implementation.
 */


function wrapInGenericFocusZone(FocusZone, props, children) {
  props[FOCUSZONE_WRAP_ATTRIBUTE] = true;
  return React.createElement(FocusZone, props, children);
}

var renderWithFocusZone = function renderWithFocusZone(render, focusZoneDefinition, config) {
  if (focusZoneDefinition.mode === FocusZoneMode.Wrap) {
    return wrapInGenericFocusZone(FocusZone, Object.assign({}, focusZoneDefinition.props, {
      isRtl: config.rtl
    }), render(config));
  }

  if (focusZoneDefinition.mode === FocusZoneMode.Embed) {
    var originalElementType = config.ElementType;
    config.ElementType = FocusZone;
    config.unhandledProps = Object.assign({}, config.unhandledProps, focusZoneDefinition.props);
    config.unhandledProps.as = originalElementType;
    config.unhandledProps.isRtl = config.rtl;
  }

  return render(config);
};

var renderComponent = function renderComponent(config, context) {
  var className = config.className,
      displayName = config.displayName,
      handledProps = config.handledProps,
      props = config.props,
      state = config.state,
      actionHandlers = config.actionHandlers,
      render = config.render,
      _config$saveDebug = config.saveDebug,
      saveDebug = _config$saveDebug === void 0 ? function () {} : _config$saveDebug;

  if (_isEmpty(context)) {
    logProviderMissingWarning();
  }

  var _ref = context || {},
      _ref$disableAnimation = _ref.disableAnimations,
      disableAnimations = _ref$disableAnimation === void 0 ? false : _ref$disableAnimation,
      _ref$renderer = _ref.renderer,
      renderer = _ref$renderer === void 0 ? null : _ref$renderer,
      _ref$rtl = _ref.rtl,
      rtl = _ref$rtl === void 0 ? false : _ref$rtl,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? emptyTheme : _ref$theme,
      _ref$telemetry = _ref.telemetry,
      telemetry = _ref$telemetry === void 0 ? undefined : _ref$telemetry,
      _ref$_internal_resolv = _ref._internal_resolvedComponentVariables,
      resolvedComponentVariables = _ref$_internal_resolv === void 0 ? {} : _ref$_internal_resolv;

  var startTime = telemetry && telemetry.enabled ? performance.now() : 0;
  var ElementType = getElementType(props);
  var stateAndProps = Object.assign({}, state, props); // Resolve variables for this component, cache the result in provider

  if (!resolvedComponentVariables[displayName]) {
    resolvedComponentVariables[displayName] = callable(theme.componentVariables[displayName])(theme.siteVariables) || {}; // component variables must not be undefined/null (see mergeComponentVariables contract)
  } // Merge inline variables on top of cached variables


  var resolvedVariables = props.variables ? mergeComponentVariables(resolvedComponentVariables[displayName], withDebugId(props.variables, 'props.variables'))(theme.siteVariables) : resolvedComponentVariables[displayName];
  var animationCSSProp = props.animation ? createAnimationStyles(props.animation, context.theme) : {}; // Resolve styles using resolved variables, merge results, allow props.styles to override

  var mergedStyles = mergeComponentStyles(theme.componentStyles[displayName], withDebugId({
    root: props.design
  }, 'props.design'), withDebugId({
    root: props.styles
  }, 'props.styles'), withDebugId({
    root: animationCSSProp
  }, 'props.animation'));
  var accessibility = getAccessibility(displayName, stateAndProps, actionHandlers, rtl);
  var unhandledProps = getUnhandledProps(handledProps, props);
  var styleParam = {
    displayName: displayName,
    props: stateAndProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations // Fela plugins rely on `direction` param in `theme` prop instead of RTL
    // Our API should be aligned with it
    // Heads Up! Keep in sync with Design.tsx render logic

  };
  var direction = rtl ? 'rtl' : 'ltr';
  var felaParam = {
    theme: {
      direction: direction
    },
    displayName: displayName // does not affect styles, only used by useEnhancedRenderer in docs

  };

  var _resolveStylesAndClas = resolveStylesAndClasses(mergedStyles, styleParam, renderer ? function (style) {
    return renderer.renderRule(function () {
      return style;
    }, felaParam);
  } : undefined),
      resolvedStyles = _resolveStylesAndClas.resolvedStyles,
      resolvedStylesDebug = _resolveStylesAndClas.resolvedStylesDebug,
      classes = _resolveStylesAndClas.classes;

  classes.root = cx(className, classes.root, props.className);
  var resolvedConfig = {
    ElementType: ElementType,
    unhandledProps: unhandledProps,
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    accessibility: accessibility,
    rtl: rtl,
    theme: theme
  };
  var result;

  if (accessibility.focusZone) {
    result = renderWithFocusZone(render, accessibility.focusZone, resolvedConfig);
  } else {
    result = render(resolvedConfig);
  } // conditionally add sources for evaluating debug information to component


  if (process.env.NODE_ENV !== 'production' && isDebugEnabled) {
    saveDebug({
      componentName: displayName,
      componentVariables: _filter(resolvedVariables._debug, function (variables) {
        return !_isEmpty(variables.resolved);
      }),
      componentStyles: resolvedStylesDebug,
      siteVariables: _filter(theme.siteVariables._debug, function (siteVars) {
        if (_isEmpty(siteVars) || _isEmpty(siteVars.resolved)) {
          return false;
        }

        var keys = Object.keys(siteVars.resolved);

        if (keys.length === 1 && keys.pop() === 'fontSizes' && _isEmpty(siteVars.resolved['fontSizes'])) {
          return false;
        }

        return true;
      })
    });
  }

  if (telemetry && telemetry.enabled) {
    var duration = performance.now() - startTime;

    if (telemetry.performance[displayName]) {
      telemetry.performance[displayName].count++;
      telemetry.performance[displayName].msTotal += duration;
      telemetry.performance[displayName].msMin = Math.min(duration, telemetry.performance[displayName].msMin);
      telemetry.performance[displayName].msMax = Math.max(duration, telemetry.performance[displayName].msMax);
    } else {
      telemetry.performance[displayName] = {
        count: 1,
        msTotal: duration,
        msMin: duration,
        msMax: duration
      };
    }
  }

  return result;
};

export default renderComponent;