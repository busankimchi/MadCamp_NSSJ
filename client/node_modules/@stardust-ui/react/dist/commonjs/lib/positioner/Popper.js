"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _merge2 = _interopRequireDefault(require("lodash/merge"));

var React = _interopRequireWildcard(require("react"));

var _PopperJS = _interopRequireWildcard(require("popper.js"));

var _reactComponentRef = require("@stardust-ui/react-component-ref");

var _positioningHelper = require("./positioningHelper");

var _getScrollParent = _interopRequireDefault(require("./getScrollParent"));

// `popper.js` has a UMD build without `.default`, it breaks CJS builds:
// https://github.com/rollup/rollup/issues/1267#issuecomment-446681320
var createPopper = function createPopper(reference, popper, options) {
  var instance = new (_PopperJS.default || _PopperJS)(reference, popper, Object.assign({}, options, {
    eventsEnabled: false
  }));
  var actualWindow = popper.ownerDocument.defaultView;

  instance.scheduleUpdate = function () {
    return actualWindow.requestAnimationFrame(instance.update);
  };

  instance.enableEventListeners();
  return instance;
};
/**
 * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.
 */


var Popper = function Popper(props) {
  var align = props.align,
      children = props.children,
      enabled = props.enabled,
      userModifiers = props.modifiers,
      offset = props.offset,
      pointerTargetRef = props.pointerTargetRef,
      position = props.position,
      positionFixed = props.positionFixed,
      _props$positioningDep = props.positioningDependencies,
      positioningDependencies = _props$positioningDep === void 0 ? [] : _props$positioningDep,
      rtl = props.rtl,
      targetRef = props.targetRef,
      unstable_pinned = props.unstable_pinned;
  var proposedPlacement = (0, _positioningHelper.getPlacement)({
    align: align,
    position: position,
    rtl: rtl
  });
  var popperRef = React.useRef();
  var contentRef = React.useRef(null);
  var latestPlacement = React.useRef(proposedPlacement);

  var _React$useState = React.useState(proposedPlacement),
      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
      computedPlacement = _React$useState2[0],
      setComputedPlacement = _React$useState2[1];

  var computedModifiers = React.useMemo(function () {
    return offset && {
      offset: {
        offset: rtl ? (0, _positioningHelper.applyRtlToOffset)(offset, position) : offset
      },
      keepTogether: {
        enabled: false
      }
    };
  }, [rtl, offset, position]);
  var scheduleUpdate = React.useCallback(function () {
    if (popperRef.current) {
      popperRef.current.scheduleUpdate();
    }
  }, []);
  var destroyInstance = React.useCallback(function () {
    if (popperRef.current) {
      popperRef.current.destroy();

      if (popperRef.current.popper) {
        // Popper keeps a reference to the DOM node, which needs to be cleaned up
        // temporarily fix it here until fixed properly in popper
        popperRef.current.popper = null;
      }

      popperRef.current = null;
    }
  }, []);
  var createInstance = React.useCallback(function () {
    destroyInstance();
    var reference = targetRef && (0, _reactComponentRef.isRefObject)(targetRef) ? targetRef.current : targetRef;

    if (!enabled || !reference || !contentRef.current) {
      return;
    }

    var pointerTargetRefElement = pointerTargetRef && pointerTargetRef.current;
    var scrollParentElement = (0, _getScrollParent.default)(contentRef.current);
    var popperHasScrollableParent = scrollParentElement !== scrollParentElement.ownerDocument.body;
    var modifiers = (0, _merge2.default)({
      preventOverflow: {
        padding: 0
      }
    }, {
      flip: {
        padding: 0,
        flipVariationsByContent: true
      }
    },
    /**
     * This prevents blurrines in chrome, when the coordinates are odd numbers
     * alternative would be to use `fn`, call _PopperJS.default.Defaults.modifiers.computeStyle.fn(data, options)
     * and manipulate the computeed style or ask popper to fix it
     * but since there is presumably only handful of poppers displayed on the page, the performance impact should be minimal
     */
    {
      computeStyle: {
        gpuAcceleration: false
      }
    },
    /**
     * When the popper box is placed in the context of a scrollable element, we need to set
     * preventOverflow.escapeWithReference to true and flip.boundariesElement to 'scrollParent' (default is 'viewport')
     * so that the popper box will stick with the targetRef when we scroll targetRef out of the viewport.
     */
    popperHasScrollableParent && {
      preventOverflow: {
        escapeWithReference: true
      },
      flip: {
        boundariesElement: 'scrollParent'
      }
    },
    /**
     * unstable_pinned disables the flip modifier by setting flip.enabled to false; this disables automatic
     * repositioning of the popper box; it will always be placed according to the values of `align` and
     * `position` props, regardless of the size of the component, the reference element or the viewport.
     */
    unstable_pinned && {
      flip: {
        enabled: false
      }
    }, computedModifiers, userModifiers,
    /**
     * This modifier is necessary in order to render the pointer.
     */
    {
      arrow: {
        enabled: !!pointerTargetRefElement,
        element: pointerTargetRefElement
      }
    });

    var handleUpdate = function handleUpdate(data) {
      // PopperJS performs computations that might update the computed placement: auto positioning, flipping the
      // placement in case the popper box should be rendered at the edge of the viewport and does not fit
      if (data.placement !== latestPlacement.current) {
        latestPlacement.current = data.placement;
        setComputedPlacement(data.placement);
      }
    };

    var options = {
      placement: proposedPlacement,
      positionFixed: positionFixed,
      modifiers: modifiers,
      onCreate: handleUpdate,
      onUpdate: handleUpdate
    };
    popperRef.current = createPopper(reference, contentRef.current, options);
  }, [// TODO review dependencies for popperHasScrollableParent
  computedModifiers, enabled, userModifiers, positionFixed, proposedPlacement, unstable_pinned, targetRef]);
  React.useLayoutEffect(function () {
    createInstance();
    return destroyInstance;
  }, [createInstance]);
  React.useEffect(scheduleUpdate, [].concat((0, _toConsumableArray2.default)(positioningDependencies), [computedPlacement]));
  var child = typeof children === 'function' ? children({
    placement: computedPlacement,
    scheduleUpdate: scheduleUpdate
  }) : children;
  return React.createElement(_reactComponentRef.Ref, {
    innerRef: contentRef
  }, React.Children.only(child));
};

Popper.defaultProps = {
  enabled: true,
  positionFixed: false,
  positioningDependencies: []
};
var _default = Popper;
exports.default = _default;