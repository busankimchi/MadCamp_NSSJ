"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _filter2 = _interopRequireDefault(require("lodash/filter"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _accessibility = require("@stardust-ui/accessibility");

var _reactBindings = require("@stardust-ui/react-bindings");

var _classnames = _interopRequireDefault(require("classnames"));

var React = _interopRequireWildcard(require("react"));

var _providerMissingHandler = _interopRequireDefault(require("./providerMissingHandler"));

var _getKeyDownHandlers = _interopRequireDefault(require("./getKeyDownHandlers"));

var _mergeThemes = require("./mergeThemes");

var _createAnimationStyles = _interopRequireDefault(require("./createAnimationStyles"));

var _debugEnabled = require("./debug/debugEnabled");

var _withDebugId = _interopRequireDefault(require("./withDebugId"));

var _resolveStylesAndClasses = _interopRequireDefault(require("./resolveStylesAndClasses"));

var emptyBehavior = {
  attributes: {},
  keyHandlers: {}
};

var getAccessibility = function getAccessibility(displayName, props, actionHandlers, isRtlEnabled) {
  var accessibility = props.accessibility;

  if ((0, _isNil2.default)(accessibility)) {
    return emptyBehavior;
  }

  var definition = accessibility(props);
  var keyHandlers = (0, _getKeyDownHandlers.default)(actionHandlers, definition.keyActions, isRtlEnabled);

  if (process.env.NODE_ENV !== 'production') {
    // For the non-production builds we enable the runtime accessibility attributes validator.
    // We're adding the data-aa-class attribute which is being consumed by the validator, the
    // schema is located in @stardust-ui/ability-attributes package.
    if (definition.attributes) {
      var slotNames = Object.keys(definition.attributes);
      slotNames.forEach(function (slotName) {
        if (!definition.attributes[slotName]) {
          definition.attributes[slotName] = {};
        }

        definition.attributes[slotName]['data-aa-class'] = "".concat(displayName).concat(slotName === 'root' ? '' : "__".concat(slotName));
      });
    }
  }

  return Object.assign({}, emptyBehavior, definition, {
    keyHandlers: keyHandlers
  });
};
/**
 * This function provides compile-time type checking for the following:
 * - if FocusZone implements FocusZone interface,
 * - if FocusZone properties extend FocusZoneProps, and
 * - if the passed properties extend FocusZoneProps.
 *
 * Should the FocusZone implementation change at any time, this function should provide a compile-time guarantee
 * that the new implementation is backwards compatible with the old implementation.
 */


function wrapInGenericFocusZone(FocusZone, props, children) {
  props[_reactBindings.FOCUSZONE_WRAP_ATTRIBUTE] = true;
  return React.createElement(FocusZone, props, children);
}

var renderWithFocusZone = function renderWithFocusZone(render, focusZoneDefinition, config) {
  if (focusZoneDefinition.mode === _accessibility.FocusZoneMode.Wrap) {
    return wrapInGenericFocusZone(_reactBindings.FocusZone, Object.assign({}, focusZoneDefinition.props, {
      isRtl: config.rtl
    }), render(config));
  }

  if (focusZoneDefinition.mode === _accessibility.FocusZoneMode.Embed) {
    var originalElementType = config.ElementType;
    config.ElementType = _reactBindings.FocusZone;
    config.unhandledProps = Object.assign({}, config.unhandledProps, focusZoneDefinition.props);
    config.unhandledProps.as = originalElementType;
    config.unhandledProps.isRtl = config.rtl;
  }

  return render(config);
};

var renderComponent = function renderComponent(config, context) {
  var className = config.className,
      displayName = config.displayName,
      handledProps = config.handledProps,
      props = config.props,
      state = config.state,
      actionHandlers = config.actionHandlers,
      render = config.render,
      _config$saveDebug = config.saveDebug,
      saveDebug = _config$saveDebug === void 0 ? function () {} : _config$saveDebug;

  if ((0, _isEmpty2.default)(context)) {
    (0, _providerMissingHandler.default)();
  }

  var _ref = context || {},
      _ref$disableAnimation = _ref.disableAnimations,
      disableAnimations = _ref$disableAnimation === void 0 ? false : _ref$disableAnimation,
      _ref$renderer = _ref.renderer,
      renderer = _ref$renderer === void 0 ? null : _ref$renderer,
      _ref$rtl = _ref.rtl,
      rtl = _ref$rtl === void 0 ? false : _ref$rtl,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? _mergeThemes.emptyTheme : _ref$theme,
      _ref$telemetry = _ref.telemetry,
      telemetry = _ref$telemetry === void 0 ? undefined : _ref$telemetry,
      _ref$_internal_resolv = _ref._internal_resolvedComponentVariables,
      resolvedComponentVariables = _ref$_internal_resolv === void 0 ? {} : _ref$_internal_resolv;

  var startTime = telemetry && telemetry.enabled ? performance.now() : 0;
  var ElementType = (0, _reactBindings.getElementType)(props);
  var stateAndProps = Object.assign({}, state, props); // Resolve variables for this component, cache the result in provider

  if (!resolvedComponentVariables[displayName]) {
    resolvedComponentVariables[displayName] = (0, _reactBindings.callable)(theme.componentVariables[displayName])(theme.siteVariables) || {}; // component variables must not be undefined/null (see mergeComponentVariables contract)
  } // Merge inline variables on top of cached variables


  var resolvedVariables = props.variables ? (0, _mergeThemes.mergeComponentVariables)(resolvedComponentVariables[displayName], (0, _withDebugId.default)(props.variables, 'props.variables'))(theme.siteVariables) : resolvedComponentVariables[displayName];
  var animationCSSProp = props.animation ? (0, _createAnimationStyles.default)(props.animation, context.theme) : {}; // Resolve styles using resolved variables, merge results, allow props.styles to override

  var mergedStyles = (0, _mergeThemes.mergeComponentStyles)(theme.componentStyles[displayName], (0, _withDebugId.default)({
    root: props.design
  }, 'props.design'), (0, _withDebugId.default)({
    root: props.styles
  }, 'props.styles'), (0, _withDebugId.default)({
    root: animationCSSProp
  }, 'props.animation'));
  var accessibility = getAccessibility(displayName, stateAndProps, actionHandlers, rtl);
  var unhandledProps = (0, _reactBindings.getUnhandledProps)(handledProps, props);
  var styleParam = {
    displayName: displayName,
    props: stateAndProps,
    variables: resolvedVariables,
    theme: theme,
    rtl: rtl,
    disableAnimations: disableAnimations // Fela plugins rely on `direction` param in `theme` prop instead of RTL
    // Our API should be aligned with it
    // Heads Up! Keep in sync with Design.tsx render logic

  };
  var direction = rtl ? 'rtl' : 'ltr';
  var felaParam = {
    theme: {
      direction: direction
    },
    displayName: displayName // does not affect styles, only used by useEnhancedRenderer in docs

  };

  var _resolveStylesAndClas = (0, _resolveStylesAndClasses.default)(mergedStyles, styleParam, renderer ? function (style) {
    return renderer.renderRule(function () {
      return style;
    }, felaParam);
  } : undefined),
      resolvedStyles = _resolveStylesAndClas.resolvedStyles,
      resolvedStylesDebug = _resolveStylesAndClas.resolvedStylesDebug,
      classes = _resolveStylesAndClas.classes;

  classes.root = (0, _classnames.default)(className, classes.root, props.className);
  var resolvedConfig = {
    ElementType: ElementType,
    unhandledProps: unhandledProps,
    classes: classes,
    variables: resolvedVariables,
    styles: resolvedStyles,
    accessibility: accessibility,
    rtl: rtl,
    theme: theme
  };
  var result;

  if (accessibility.focusZone) {
    result = renderWithFocusZone(render, accessibility.focusZone, resolvedConfig);
  } else {
    result = render(resolvedConfig);
  } // conditionally add sources for evaluating debug information to component


  if (process.env.NODE_ENV !== 'production' && _debugEnabled.isEnabled) {
    saveDebug({
      componentName: displayName,
      componentVariables: (0, _filter2.default)(resolvedVariables._debug, function (variables) {
        return !(0, _isEmpty2.default)(variables.resolved);
      }),
      componentStyles: resolvedStylesDebug,
      siteVariables: (0, _filter2.default)(theme.siteVariables._debug, function (siteVars) {
        if ((0, _isEmpty2.default)(siteVars) || (0, _isEmpty2.default)(siteVars.resolved)) {
          return false;
        }

        var keys = Object.keys(siteVars.resolved);

        if (keys.length === 1 && keys.pop() === 'fontSizes' && (0, _isEmpty2.default)(siteVars.resolved['fontSizes'])) {
          return false;
        }

        return true;
      })
    });
  }

  if (telemetry && telemetry.enabled) {
    var duration = performance.now() - startTime;

    if (telemetry.performance[displayName]) {
      telemetry.performance[displayName].count++;
      telemetry.performance[displayName].msTotal += duration;
      telemetry.performance[displayName].msMin = Math.min(duration, telemetry.performance[displayName].msMin);
      telemetry.performance[displayName].msMax = Math.max(duration, telemetry.performance[displayName].msMax);
    } else {
      telemetry.performance[displayName] = {
        count: 1,
        msTotal: duration,
        msMin: duration,
        msMax: duration
      };
    }
  }

  return result;
};

var _default = renderComponent;
exports.default = _default;