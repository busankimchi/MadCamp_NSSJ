"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var _some2 = _interopRequireDefault(require("lodash/some"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _accessibility = require("@stardust-ui/accessibility");

var _reactComponentEventListener = require("@stardust-ui/react-component-event-listener");

var _reactComponentNestingRegistry = require("@stardust-ui/react-component-nesting-registry");

var _reactComponentRef = require("@stardust-ui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@stardust-ui/react-proptypes"));

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var keyboardKey = _interopRequireWildcard(require("keyboard-key"));

var _lib = require("../../lib");

var _positioner = require("../../lib/positioner");

var _PopupContent = _interopRequireDefault(require("./PopupContent"));

var _factories = require("../../lib/factories");

var _createReferenceFromContextClick = _interopRequireDefault(require("./createReferenceFromContextClick"));

var _isRightClick = _interopRequireDefault(require("../../lib/isRightClick"));

var _PortalInner = _interopRequireDefault(require("../Portal/PortalInner"));

/**
 * A Popup displays a non-modal, often rich content, on top of its target element.
 */
var Popup =
/*#__PURE__*/
function (_AutoControlledCompon) {
  (0, _inherits2.default)(Popup, _AutoControlledCompon);

  function Popup() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Popup);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Popup)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "pointerTargetRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "triggerRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "triggerFocusableDomElement", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "popupDomElement", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rightClickReferenceObject", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "closeTimeoutId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "actionHandlers", {
      closeAndFocusTrigger: function closeAndFocusTrigger(e) {
        _this.close(e, function () {
          return (0, _invoke2.default)(_this.triggerFocusableDomElement, 'focus');
        });
      },
      close: function close(e) {
        _this.close(e);
      },
      toggle: function toggle(e) {
        e.preventDefault();

        _this.trySetOpen(!_this.state.open, e);
      },
      open: function open(e) {
        e.preventDefault();

        _this.setPopupOpen(true, e);
      },
      preventScroll: function preventScroll(e) {
        e.preventDefault();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleDocumentClick", function (getRefs) {
      return function (e) {
        if (_this.state.isOpenedByRightClick && _this.isOutsidePopupElement(getRefs(), e)) {
          _this.trySetOpen(false, e);

          return;
        }

        if (_this.isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
          _this.trySetOpen(false, e);
        }
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleDocumentKeyDown", function (getRefs) {
      return function (e) {
        var keyCode = keyboardKey.getCode(e);
        var isMatchingKey = keyCode === keyboardKey.Enter || keyCode === keyboardKey.Spacebar;

        if (isMatchingKey && _this.isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
          _this.trySetOpen(false, e);
        } // if focus was lost from Popup and moved to body, for e.g. when click on popup content
        // and ESC is pressed, the last opened Popup should get closed and the trigger should get focus


        var lastContentRef = getRefs().pop();
        var isLastOpenedPopup = lastContentRef && lastContentRef.current === _this.popupDomElement;
        var activeDocument = _this.props.mountDocument || _this.context.target;
        var bodyHasFocus = activeDocument.activeElement === activeDocument.body;

        if (keyCode === keyboardKey.Escape && bodyHasFocus && isLastOpenedPopup) {
          _this.close(e, function () {
            return (0, _invoke2.default)(_this.triggerFocusableDomElement, 'focus');
          });
        }
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getContentProps", function (predefinedProps) {
      var contentHandlerProps = {};
      var on = _this.props.on;
      var normalizedOn = (0, _isArray2.default)(on) ? on : [on];
      /**
       * The focus is adding the focus and blur events on the content
       */

      if ((0, _includes2.default)(normalizedOn, 'focus')) {
        contentHandlerProps.onFocus = function (e, contentProps) {
          _this.trySetOpen(true, e);

          predefinedProps && (0, _invoke2.default)(predefinedProps, 'onFocus', e, contentProps);
        };

        contentHandlerProps.onBlur = function (e, contentProps) {
          if (_this.shouldBlurClose(e)) {
            _this.trySetOpen(false, e);
          }

          predefinedProps && (0, _invoke2.default)(predefinedProps, 'onBlur', e, contentProps);
        };
      }
      /**
       * The hover is adding the mouseEnter, mouseLeave and click event (always opening on click)
       */


      if ((0, _includes2.default)(normalizedOn, 'hover')) {
        contentHandlerProps.onMouseEnter = function (e, contentProps) {
          _this.setPopupOpen(true, e);

          predefinedProps && (0, _invoke2.default)(predefinedProps, 'onMouseEnter', e, contentProps);
        };

        contentHandlerProps.onMouseLeave = function (e, contentProps) {
          _this.setPopupOpen(false, e);

          predefinedProps && (0, _invoke2.default)(predefinedProps, 'onMouseLeave', e, contentProps);
        };

        contentHandlerProps.onClick = function (e, contentProps) {
          _this.setPopupOpen(true, e);

          predefinedProps && (0, _invoke2.default)(predefinedProps, 'onClick', e, contentProps);
        };
      }

      return contentHandlerProps;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "shouldBlurClose", function (e) {
      return !e.currentTarget || !_this.popupDomElement || !e.currentTarget.contains(e.relatedTarget) && !_this.popupDomElement.contains(e.relatedTarget);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderPopperChildren", function (popupPositionClasses, rtl, accessibility, _ref) {
      var placement = _ref.placement,
          scheduleUpdate = _ref.scheduleUpdate;
      var _this$props = _this.props,
          propsContent = _this$props.content,
          renderContent = _this$props.renderContent,
          contentRef = _this$props.contentRef,
          mountDocument = _this$props.mountDocument,
          pointing = _this$props.pointing,
          trapFocus = _this$props.trapFocus,
          autoFocus = _this$props.autoFocus;
      var content = renderContent ? renderContent(scheduleUpdate) : propsContent;
      var targetRef = (0, _reactComponentRef.toRefObject)(mountDocument || _this.context.target);
      var popupContent = Popup.Content.create(content || {}, {
        defaultProps: function defaultProps() {
          return Object.assign({}, rtl && {
            dir: 'rtl'
          }, accessibility.attributes.popup, accessibility.keyHandlers.popup, {
            className: popupPositionClasses
          }, _this.getContentProps(), {
            placement: placement,
            pointing: pointing,
            pointerRef: _this.pointerTargetRef,
            trapFocus: trapFocus,
            autoFocus: autoFocus
          });
        },
        overrideProps: _this.getContentProps
      });
      return React.createElement(_reactComponentNestingRegistry.Unstable_NestingAuto, null, function (getRefs, nestingRef) {
        return React.createElement(React.Fragment, null, React.createElement(_reactComponentRef.Ref, {
          innerRef: function innerRef(domElement) {
            _this.popupDomElement = domElement;
            (0, _reactComponentRef.handleRef)(contentRef, domElement);
            nestingRef.current = domElement;
          }
        }, popupContent), React.createElement(_reactComponentEventListener.EventListener, {
          listener: _this.handleDocumentClick(getRefs),
          targetRef: targetRef,
          type: "click",
          capture: true
        }), React.createElement(_reactComponentEventListener.EventListener, {
          listener: _this.handleDocumentClick(getRefs),
          targetRef: targetRef,
          type: "contextmenu",
          capture: true
        }), React.createElement(_reactComponentEventListener.EventListener, {
          listener: _this.handleDocumentKeyDown(getRefs),
          targetRef: targetRef,
          type: "keydown",
          capture: true
        }), _this.state.isOpenedByRightClick && React.createElement(React.Fragment, null, React.createElement(_reactComponentEventListener.EventListener, {
          listener: _this.dismissOnScroll,
          targetRef: targetRef,
          type: "wheel",
          capture: true
        }), React.createElement(_reactComponentEventListener.EventListener, {
          listener: _this.dismissOnScroll,
          targetRef: targetRef,
          type: "touchmove",
          capture: true
        })));
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "dismissOnScroll", function (e) {
      _this.trySetOpen(false, e);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "schedulePopupClose", function (e) {
      var mouseLeaveDelay = _this.props.mouseLeaveDelay;
      _this.closeTimeoutId = setTimeout(function () {
        _this.trySetOpen(false, e);
      }, mouseLeaveDelay);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "close", function (e, onClose) {
      if (_this.state.open) {
        _this.trySetOpen(false, e);

        onClose && onClose();
        e.stopPropagation();
      }
    });
    return _this;
  }

  (0, _createClass2.default)(Popup, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props,
          inline = _this$props2.inline,
          trapFocus = _this$props2.trapFocus,
          autoFocus = _this$props2.autoFocus;

      if (process.env.NODE_ENV !== 'production') {
        if (inline && trapFocus) {
          console.warn('Using "trapFocus" in inline popup leads to broken behavior for screen reader users.');
        }

        if (!inline && autoFocus) {
          console.warn('Beware, "autoFocus" prop will just grab focus at the moment of mount and will not trap it. As user is able to TAB out from popup, better use "inline" prop to keep correct tab order.');
        }
      }
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var classes = _ref2.classes,
          rtl = _ref2.rtl,
          accessibility = _ref2.accessibility;
      var _this$props3 = this.props,
          inline = _this$props3.inline,
          mountNode = _this$props3.mountNode;
      var open = this.state.open;
      var popupContent = open && this.renderPopupContent(classes.popup, rtl, accessibility);
      return React.createElement(React.Fragment, null, this.renderTrigger(accessibility), open && (inline ? popupContent : React.createElement(_PortalInner.default, {
        mountNode: mountNode
      }, popupContent)));
    }
  }, {
    key: "isOutsidePopupElementAndOutsideTriggerElement",
    value: function isOutsidePopupElementAndOutsideTriggerElement(refs, e) {
      var isOutsidePopupElement = this.isOutsidePopupElement(refs, e);
      var isOutsideTriggerElement = this.triggerRef.current && !(0, _lib.doesNodeContainClick)(this.triggerRef.current, e, this.context.target);
      return isOutsidePopupElement && isOutsideTriggerElement;
    }
  }, {
    key: "isOutsidePopupElement",
    value: function isOutsidePopupElement(refs, e) {
      var _this2 = this;

      var isInsideNested = (0, _some2.default)(refs, function (childRef) {
        return (0, _lib.doesNodeContainClick)(childRef.current, e, _this2.context.target);
      });
      var isOutsidePopupElement = this.popupDomElement && !isInsideNested;
      return isOutsidePopupElement;
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps(triggerElement) {
      var _this3 = this;

      var triggerProps = {};
      var on = this.props.on;
      var normalizedOn = (0, _isArray2.default)(on) ? on : [on];
      /**
       * The focus is adding the focus, blur and click event (always opening on click)
       * If focus and context are provided, there is no need to add onClick
       */

      if ((0, _includes2.default)(normalizedOn, 'focus')) {
        triggerProps.onFocus = function (e) {
          if ((0, _lib.isFromKeyboard)()) {
            _this3.trySetOpen(true, e);
          }

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onFocus', e].concat(args));
        };

        triggerProps.onBlur = function (e) {
          if (_this3.shouldBlurClose(e)) {
            _this3.trySetOpen(false, e);
          }

          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
        };

        if (!(0, _includes2.default)(normalizedOn, 'context')) {
          triggerProps.onClick = function (e) {
            _this3.setPopupOpen(true, e);

            for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
              args[_key4 - 1] = arguments[_key4];
            }

            _invoke2.default.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
          };
        }
      }
      /**
       * The click is toggling the open state of the popup
       */


      if ((0, _includes2.default)(normalizedOn, 'click')) {
        triggerProps.onClick = function (e) {
          _this3.trySetOpen(!_this3.state.open, e);

          for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            args[_key5 - 1] = arguments[_key5];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
        };
      }
      /**
       * The context is opening the popup
       */


      if ((0, _includes2.default)(normalizedOn, 'context')) {
        triggerProps.onContextMenu = function (e) {
          _this3.setPopupOpen(!_this3.state.open, e);

          for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
            args[_key6 - 1] = arguments[_key6];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onContextMenu', e].concat(args));

          e.preventDefault();
        };
      }
      /**
       * The hover is adding the mouseEnter, mouseLeave, blur and click event (always opening on click)
       * If hover and context are provided, there is no need to add onClick
       */


      if ((0, _includes2.default)(normalizedOn, 'hover')) {
        triggerProps.onMouseEnter = function (e) {
          _this3.setPopupOpen(true, e);

          (0, _lib.setWhatInputSource)('mouse');

          for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
            args[_key7 - 1] = arguments[_key7];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseEnter', e].concat(args));
        };

        triggerProps.onMouseLeave = function (e) {
          _this3.setPopupOpen(false, e);

          for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
            args[_key8 - 1] = arguments[_key8];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseLeave', e].concat(args));
        };

        if (!(0, _includes2.default)(normalizedOn, 'context')) {
          triggerProps.onClick = function (e) {
            _this3.setPopupOpen(true, e);

            for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
              args[_key9 - 1] = arguments[_key9];
            }

            _invoke2.default.apply(void 0, [triggerElement, 'props.onClick', e].concat(args));
          };
        }

        triggerProps.onBlur = function (e) {
          if (_this3.shouldBlurClose(e)) {
            _this3.trySetOpen(false, e);
          }

          for (var _len10 = arguments.length, args = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
            args[_key10 - 1] = arguments[_key10];
          }

          _invoke2.default.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
        };
      }

      return triggerProps;
    }
  }, {
    key: "renderTrigger",
    value: function renderTrigger(accessibility) {
      var _this$props4 = this.props,
          children = _this$props4.children,
          trigger = _this$props4.trigger;
      var triggerElement = (0, _lib.childrenExist)(children) ? children : trigger;
      var triggerProps = this.getTriggerProps(triggerElement);
      return triggerElement && React.createElement(_reactComponentRef.Ref, {
        innerRef: this.triggerRef
      }, React.cloneElement(triggerElement, Object.assign({}, accessibility.attributes.trigger, triggerProps, (0, _lib.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.trigger, triggerProps))));
    }
  }, {
    key: "renderPopupContent",
    value: function renderPopupContent(popupPositionClasses, rtl, accessibility) {
      var _this$props5 = this.props,
          align = _this$props5.align,
          position = _this$props5.position,
          offset = _this$props5.offset,
          target = _this$props5.target,
          unstable_pinned = _this$props5.unstable_pinned;
      return React.createElement(_positioner.Popper, {
        pointerTargetRef: this.pointerTargetRef,
        align: align,
        position: position,
        offset: offset,
        rtl: rtl,
        unstable_pinned: unstable_pinned,
        targetRef: this.rightClickReferenceObject || (target ? (0, _reactComponentRef.toRefObject)(target) : this.triggerRef),
        children: this.renderPopperChildren.bind(this, popupPositionClasses, rtl, accessibility)
      });
    }
  }, {
    key: "trySetOpen",
    value: function trySetOpen(newValue, eventArgs) {
      var isOpenedByRightClick = newValue && (0, _isRightClick.default)(eventArgs); // when new state 'open' === 'true', save the last focused element

      if (newValue) {
        this.updateTriggerFocusableDomElement();
        this.updateContextPosition(isOpenedByRightClick && eventArgs.nativeEvent);
      }

      this.setState({
        open: newValue,
        isOpenedByRightClick: isOpenedByRightClick
      });
      (0, _invoke2.default)(this.props, 'onOpenChange', eventArgs, Object.assign({}, this.props, {
        open: newValue
      }));
    }
  }, {
    key: "setPopupOpen",
    value: function setPopupOpen(newOpen, e) {
      clearTimeout(this.closeTimeoutId);
      newOpen ? this.trySetOpen(true, e) : this.schedulePopupClose(e);
    }
  }, {
    key: "updateTriggerFocusableDomElement",

    /**
     * Save DOM element which had focus before Popup opens.
     * Can be either trigger DOM element itself or the element inside it.
     */
    value: function updateTriggerFocusableDomElement() {
      var mountDocument = this.props.mountDocument;
      var activeDocument = mountDocument || this.context.target;
      var activeElement = activeDocument.activeElement;
      this.triggerFocusableDomElement = this.triggerRef.current.contains(activeElement) ? activeElement : this.triggerRef.current;
    }
  }, {
    key: "updateContextPosition",
    value: function updateContextPosition(nativeEvent) {
      this.rightClickReferenceObject = nativeEvent && (0, _createReferenceFromContextClick.default)(nativeEvent);
    }
  }]);
  return Popup;
}(_lib.AutoControlledComponent);

exports.default = Popup;
(0, _defineProperty2.default)(Popup, "displayName", 'Popup');
(0, _defineProperty2.default)(Popup, "className", 'ui-popup');
(0, _defineProperty2.default)(Popup, "create", void 0);
(0, _defineProperty2.default)(Popup, "slotClassNames", {
  content: "".concat(Popup.className, "__content")
});
(0, _defineProperty2.default)(Popup, "Content", _PopupContent.default);
(0, _defineProperty2.default)(Popup, "propTypes", Object.assign({}, _lib.commonPropTypes.createCommon({
  animated: false,
  as: false,
  content: false
}), {
  align: PropTypes.oneOf(_positioner.ALIGNMENTS),
  defaultOpen: PropTypes.bool,
  inline: PropTypes.bool,
  mountDocument: PropTypes.object,
  mountNode: customPropTypes.domNode,
  mouseLeaveDelay: PropTypes.number,
  offset: PropTypes.string,
  on: PropTypes.oneOfType([PropTypes.oneOf(['hover', 'click', 'focus', 'context']), PropTypes.arrayOf(PropTypes.oneOf(['click', 'focus', 'context'])), PropTypes.arrayOf(PropTypes.oneOf(['hover', 'focus', 'context']))]),
  open: PropTypes.bool,
  onOpenChange: PropTypes.func,
  pointing: PropTypes.bool,
  position: PropTypes.oneOf(_positioner.POSITIONS),
  renderContent: PropTypes.func,
  target: PropTypes.any,
  trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.any]),
  tabbableTrigger: PropTypes.bool,
  unstable_pinned: PropTypes.bool,
  content: customPropTypes.shorthandAllowingChildren,
  contentRef: customPropTypes.ref,
  trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
  autoFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object])
}));
(0, _defineProperty2.default)(Popup, "defaultProps", {
  accessibility: _accessibility.popupBehavior,
  align: 'start',
  position: 'above',
  on: 'click',
  mouseLeaveDelay: 500,
  tabbableTrigger: true
});
(0, _defineProperty2.default)(Popup, "autoControlledProps", ['open']);
Popup.create = (0, _factories.createShorthandFactory)({
  Component: Popup,
  mappedProp: 'content'
});