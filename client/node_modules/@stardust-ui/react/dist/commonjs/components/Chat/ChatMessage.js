"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _accessibility = require("@stardust-ui/accessibility");

var customPropTypes = _interopRequireWildcard(require("@stardust-ui/react-proptypes"));

var _reactComponentRef = require("@stardust-ui/react-component-ref");

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _positioner = require("../../lib/positioner");

var _lib = require("../../lib");

var _types = require("../../types");

var _Box = _interopRequireDefault(require("../Box/Box"));

var _Label = _interopRequireDefault(require("../Label/Label"));

var _Menu = _interopRequireDefault(require("../Menu/Menu"));

var _Text = _interopRequireDefault(require("../Text/Text"));

var _Reaction = _interopRequireDefault(require("../Reaction/Reaction"));

var ChatMessage =
/*#__PURE__*/
function (_UIComponent) {
  (0, _inherits2.default)(ChatMessage, _UIComponent);

  function ChatMessage() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, ChatMessage);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(ChatMessage)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "updateActionsMenuPosition", function () {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
      focused: false,
      messageNode: null
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "menuRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "actionHandlers", {
      // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
      // as navigation (only Tab key should work)
      preventDefault: function preventDefault(event) {
        event.preventDefault();
      },
      focus: function focus(event) {
        if (_this.state.messageNode) {
          _this.state.messageNode.focus();

          event.stopPropagation();
        }
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleFocus", function (e) {
      _this.updateActionsMenuPosition();

      _this.setState({
        focused: true
      });

      (0, _invoke2.default)(_this.props, 'onFocus', e, _this.props);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleBlur", function (e) {
      // `this.state.focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
      // with keyboard the focused element will be changed and there is no way to use `:focus` selector
      var shouldPreserveFocusState = (0, _invoke2.default)(e, 'currentTarget.contains', e.relatedTarget);

      _this.setState({
        focused: shouldPreserveFocusState
      });

      (0, _invoke2.default)(_this.props, 'onBlur', e, _this.props);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMouseEnter", function (e) {
      _this.updateActionsMenuPosition();

      (0, _invoke2.default)(_this.props, 'onMouseEnter', e, _this.props);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleMessageRef", function (node) {
      return _this.setState({
        messageNode: node
      });
    });
    return _this;
  }

  (0, _createClass2.default)(ChatMessage, [{
    key: "renderActionMenu",
    value: function renderActionMenu(actionMenu, styles) {
      var _this2 = this;

      var _this$props = this.props,
          overflow = _this$props.unstable_overflow,
          positionActionMenu = _this$props.positionActionMenu;
      var messageNode = this.state.messageNode;

      var actionMenuElement = _Menu.default.create(actionMenu, {
        defaultProps: function defaultProps() {
          var _ref;

          return _ref = {}, (0, _defineProperty2.default)(_ref, _accessibility.IS_FOCUSABLE_ATTRIBUTE, true), (0, _defineProperty2.default)(_ref, "accessibility", _accessibility.menuAsToolbarBehavior), (0, _defineProperty2.default)(_ref, "className", ChatMessage.slotClassNames.actionMenu), (0, _defineProperty2.default)(_ref, "styles", styles.actionMenu), _ref;
        }
      });

      if (!actionMenuElement) {
        return actionMenuElement;
      }

      var menuRect = positionActionMenu && (0, _invoke2.default)(this.menuRef.current, 'getBoundingClientRect') || {
        height: 0
      };
      var messageRect = positionActionMenu && (0, _invoke2.default)(messageNode, 'getBoundingClientRect') || {
        height: 0
      };
      return React.createElement(_positioner.Popper, {
        enabled: positionActionMenu,
        align: "end",
        modifiers: positionActionMenu && {
          // https://popper.js.org/popper-documentation.html#modifiers..flip.behavior
          // Forces to flip only in "top-*" positions
          flip: {
            behavior: ['top']
          },
          preventOverflow: Object.assign({
            escapeWithReference: false,
            // https://popper.js.org/popper-documentation.html#modifiers..preventOverflow.priority
            // Forces to stop prevent overflow on bottom and bottom
            priority: ['left', 'right']
          }, overflow && {
            boundariesElement: 'scrollParent',
            escapeWithReference: true,
            padding: {
              top: messageRect.height - menuRect.height
            }
          })
        },
        position: "above",
        positionFixed: overflow,
        targetRef: messageNode
      }, function (_ref2) {
        var scheduleUpdate = _ref2.scheduleUpdate;
        _this2.updateActionsMenuPosition = scheduleUpdate;
        return React.createElement(_reactComponentRef.Ref, {
          innerRef: _this2.menuRef
        }, actionMenuElement);
      });
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref3) {
      var ElementType = _ref3.ElementType,
          classes = _ref3.classes,
          accessibility = _ref3.accessibility,
          unhandledProps = _ref3.unhandledProps,
          styles = _ref3.styles;
      var _this$props2 = this.props,
          actionMenu = _this$props2.actionMenu,
          author = _this$props2.author,
          badge = _this$props2.badge,
          badgePosition = _this$props2.badgePosition,
          children = _this$props2.children,
          content = _this$props2.content,
          timestamp = _this$props2.timestamp,
          reactionGroup = _this$props2.reactionGroup,
          reactionGroupPosition = _this$props2.reactionGroupPosition;
      var childrenPropExists = (0, _lib.childrenExist)(children);
      var className = childrenPropExists ? (0, _classnames.default)(classes.root, classes.content) : classes.root;

      var badgeElement = _Label.default.create(badge, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.badge,
            styles: styles.badge
          };
        }
      });

      var reactionGroupElement = _Reaction.default.Group.create(reactionGroup, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.reactionGroup,
            styles: styles.reactionGroup
          };
        }
      });

      var actionMenuElement = this.renderActionMenu(actionMenu, styles);

      var authorElement = _Text.default.create(author, {
        defaultProps: function defaultProps() {
          return {
            size: 'small',
            styles: styles.author,
            className: ChatMessage.slotClassNames.author
          };
        }
      });

      var timestampElement = _Text.default.create(timestamp, {
        defaultProps: function defaultProps() {
          return {
            size: 'small',
            styles: styles.timestamp,
            timestamp: true,
            className: ChatMessage.slotClassNames.timestamp
          };
        }
      });

      var messageContent = _Box.default.create(content, {
        defaultProps: function defaultProps() {
          return {
            className: ChatMessage.slotClassNames.content,
            styles: styles.content
          };
        }
      });

      return React.createElement(_reactComponentRef.Ref, {
        innerRef: this.handleMessageRef
      }, React.createElement(ElementType, (0, _extends2.default)({
        onBlur: this.handleBlur,
        onFocus: this.handleFocus,
        onMouseEnter: this.handleMouseEnter,
        className: className
      }, accessibility.attributes.root, unhandledProps, (0, _lib.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.root, unhandledProps), _lib.rtlTextContainer.getAttributes({
        forElements: [children]
      })), childrenPropExists ? children : React.createElement(React.Fragment, null, actionMenuElement, badgePosition === 'start' && badgeElement, authorElement, timestampElement, reactionGroupPosition === 'start' && reactionGroupElement, messageContent, reactionGroupPosition === 'end' && reactionGroupElement, badgePosition === 'end' && badgeElement)));
    }
  }]);
  return ChatMessage;
}(_lib.UIComponent);

(0, _defineProperty2.default)(ChatMessage, "className", 'ui-chat__message');
(0, _defineProperty2.default)(ChatMessage, "create", void 0);
(0, _defineProperty2.default)(ChatMessage, "slotClassNames", void 0);
(0, _defineProperty2.default)(ChatMessage, "displayName", 'ChatMessage');
(0, _defineProperty2.default)(ChatMessage, "__isChatMessage", true);
(0, _defineProperty2.default)(ChatMessage, "isTypeOfElement", function (element) {
  return (0, _get2.default)(element, "type.__isChatMessage");
});
(0, _defineProperty2.default)(ChatMessage, "propTypes", Object.assign({}, _lib.commonPropTypes.createCommon({
  content: 'shorthand'
}), {
  actionMenu: customPropTypes.itemShorthand,
  attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]),
  author: customPropTypes.itemShorthand,
  badge: customPropTypes.itemShorthand,
  badgePosition: PropTypes.oneOf(['start', 'end']),
  mine: PropTypes.bool,
  timestamp: customPropTypes.itemShorthand,
  onBlur: PropTypes.func,
  onFocus: PropTypes.func,
  onMouseEnter: PropTypes.func,
  positionActionMenu: PropTypes.bool,
  reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]),
  reactionGroupPosition: PropTypes.oneOf(['start', 'end']),
  unstable_overflow: PropTypes.bool
}));
(0, _defineProperty2.default)(ChatMessage, "defaultProps", {
  accessibility: _accessibility.chatMessageBehavior,
  as: 'div',
  badgePosition: 'end',
  positionActionMenu: true,
  reactionGroupPosition: 'start'
});
ChatMessage.create = (0, _lib.createShorthandFactory)({
  Component: ChatMessage,
  mappedProp: 'content'
});
ChatMessage.slotClassNames = {
  actionMenu: "".concat(ChatMessage.className, "__actions"),
  author: "".concat(ChatMessage.className, "__author"),
  timestamp: "".concat(ChatMessage.className, "__timestamp"),
  badge: "".concat(ChatMessage.className, "__badge"),
  content: "".concat(ChatMessage.className, "__content"),
  reactionGroup: "".concat(ChatMessage.className, "__reactions")
  /**
   * A ChatMessage represents a single message in chat.
   */

};

var _default = (0, _types.withSafeTypeForAs)(ChatMessage);

exports.default = _default;