"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _forEachRight2 = _interopRequireDefault(require("lodash/forEachRight"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _accessibility = require("@stardust-ui/accessibility");

var React = _interopRequireWildcard(require("react"));

var customPropTypes = _interopRequireWildcard(require("@stardust-ui/react-proptypes"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _reactComponentRef = require("@stardust-ui/react-component-ref");

var _reactComponentEventListener = require("@stardust-ui/react-component-event-listener");

var _lib = require("../../lib");

var _mergeThemes = require("../../lib/mergeThemes");

var _types = require("../../types");

var _ToolbarCustomItem = _interopRequireDefault(require("./ToolbarCustomItem"));

var _ToolbarDivider = _interopRequireDefault(require("./ToolbarDivider"));

var _ToolbarItem = _interopRequireDefault(require("./ToolbarItem"));

var _ToolbarMenu = _interopRequireDefault(require("./ToolbarMenu"));

var _ToolbarMenuDivider = _interopRequireDefault(require("./ToolbarMenuDivider"));

var _ToolbarMenuItem = _interopRequireDefault(require("./ToolbarMenuItem"));

var _ToolbarMenuRadioGroup = _interopRequireDefault(require("./ToolbarMenuRadioGroup"));

var _ToolbarRadioGroup = _interopRequireDefault(require("./ToolbarRadioGroup"));

var WAS_FOCUSABLE_ATTRIBUTE = 'data-was-focusable';

var Toolbar =
/*#__PURE__*/
function (_UIComponent) {
  (0, _inherits2.default)(Toolbar, _UIComponent);

  function Toolbar() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Toolbar);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Toolbar)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "overflowContainerRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "overflowItemRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "offsetMeasureRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "lastVisibleItemIndex", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "animationFrameId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "rtl", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleItemOverrides", function (variables) {
      return function (predefinedProps) {
        return {
          variables: (0, _mergeThemes.mergeComponentVariables)(variables, predefinedProps.variables)
        };
      };
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "hideOverflowItems", function () {
      var $overflowContainer = _this.overflowContainerRef.current;
      var $overflowItem = _this.overflowItemRef.current;
      var $offsetMeasure = _this.offsetMeasureRef.current;

      if (!$overflowContainer || !$overflowItem || !$offsetMeasure) {
        return;
      } // workaround: when resizing window with popup opened the container contents scroll for some reason


      if (_this.rtl) {
        $overflowContainer.scrollTo(Number.MAX_SAFE_INTEGER, 0);
      } else {
        $overflowContainer.scrollTo(0, 0);
      }

      var $items = $overflowContainer.children;
      var overflowContainerBoundingRect = $overflowContainer.getBoundingClientRect();
      var overflowItemBoundingRect = $overflowItem.getBoundingClientRect();
      var offsetMeasureBoundingRect = $offsetMeasure.getBoundingClientRect(); // Absolute positioning offset
      // Overflow menu is absolutely positioned relative to root slot
      // If there is padding set on the root slot boundingClientRect computations use inner content box,
      // but absolute position is relative to root slot's PADDING box.
      // We compute absolute positioning offset
      // By measuring position of an offsetMeasure element absolutely positioned to 0,0.
      // TODO: replace by getComputedStyle('padding')

      var absolutePositioningOffset = {
        horizontal: _this.rtl ? offsetMeasureBoundingRect.right - overflowContainerBoundingRect.right : overflowContainerBoundingRect.left - offsetMeasureBoundingRect.left,
        vertical: overflowContainerBoundingRect.top - offsetMeasureBoundingRect.top
      };
      var isOverflowing = false;
      var $lastVisibleItem;
      var lastVisibleItemRect; // check all items from the last one back

      (0, _forEachRight2.default)($items, function ($item, i) {
        if ($item === $overflowItem) {
          return true;
        }

        var itemBoundingRect = $item.getBoundingClientRect(); // if the item is out of the crop rectangle, hide it

        if (_this.isItemOverflowing(itemBoundingRect, overflowContainerBoundingRect)) {
          isOverflowing = true; // console.log('Overflow', i, {
          //   item: [itemBoundingRect.left, itemBoundingRect.right],
          //   crop: [
          //     overflowContainerBoundingRect.left,
          //     overflowContainerBoundingRect.right,
          //     overflowContainerBoundingRect.width,
          //   ],
          //   container: $overflowContainer,
          // })

          _this.hide($item);

          return true;
        } // if there is an overflow, check collision of remaining items with eventual overflow position


        if (isOverflowing && !$lastVisibleItem && _this.wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, overflowContainerBoundingRect)) {
          _this.hide($item);

          return true;
        } // Remember the last visible item


        if (!$lastVisibleItem) {
          $lastVisibleItem = $item;
          lastVisibleItemRect = itemBoundingRect;
          _this.lastVisibleItemIndex = i;
        }

        return _this.show($item); // exit the loop when first visible item is found
      }); // if there is an overflow,  position and show overflow item, otherwise hide it

      if (isOverflowing || _this.props.overflowOpen) {
        $overflowItem.style.position = 'absolute';

        _this.setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, overflowContainerBoundingRect, absolutePositioningOffset);

        _this.show($overflowItem);
      } else {
        _this.lastVisibleItemIndex = _this.props.items.length - 1;

        _this.hide($overflowItem);
      }

      (0, _invoke2.default)(_this.props, 'onOverflow', _this.lastVisibleItemIndex + 1);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getOverflowItems", function () {
      // console.log('getOverflowItems()', this.props.items.slice(this.lastVisibleItemIndex + 1))
      return _this.props.getOverflowItems ? _this.props.getOverflowItems(_this.lastVisibleItemIndex + 1) : _this.props.items.slice(_this.lastVisibleItemIndex + 1);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getVisibleItems", function () {
      // console.log('allItems()', this.props.items)
      var end = _this.props.overflowOpen ? _this.lastVisibleItemIndex + 1 : _this.props.items.length; // console.log('getVisibleItems()', this.props.items.slice(0, end))

      return _this.props.items.slice(0, end);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleWindowResize", (0, _debounce2.default)(function (e) {
      _this.hideOverflowItems();

      if (_this.props.overflowOpen) {
        (0, _invoke2.default)(_this.props, 'onOverflowOpenChange', e, Object.assign({}, _this.props, {
          overflowOpen: false
        }));
      }
    }, 16));
    return _this;
  }

  (0, _createClass2.default)(Toolbar, [{
    key: "renderItems",
    value: function renderItems(items, variables) {
      var itemOverridesFn = this.handleItemOverrides(variables);
      return (0, _map2.default)(items, function (item) {
        var kind = (0, _get2.default)(item, 'kind', 'item');

        switch (kind) {
          case 'divider':
            return _ToolbarDivider.default.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'group':
            return _ToolbarRadioGroup.default.create(item, {
              overrideProps: itemOverridesFn
            });

          case 'toggle':
            return _ToolbarItem.default.create(item, {
              defaultProps: function defaultProps() {
                return {
                  accessibility: _accessibility.toggleButtonBehavior
                };
              },
              overrideProps: itemOverridesFn
            });

          case 'custom':
            return _ToolbarCustomItem.default.create(item, {
              overrideProps: itemOverridesFn
            });

          default:
            return _ToolbarItem.default.create(item, {
              overrideProps: itemOverridesFn
            });
        }
      });
    }
  }, {
    key: "hide",
    value: function hide(el) {
      if (el.style.visibility === 'hidden') {
        return;
      }

      el.style.visibility = 'hidden';
      var wasFocusable = el.getAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE);

      if (wasFocusable) {
        el.setAttribute(WAS_FOCUSABLE_ATTRIBUTE, wasFocusable);
      }

      el.setAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE, 'false');
    }
  }, {
    key: "show",
    value: function show(el) {
      if (el.style.visibility !== 'hidden') {
        return false;
      }

      el.style.visibility = null;
      var wasFocusable = el.getAttribute(WAS_FOCUSABLE_ATTRIBUTE);

      if (wasFocusable) {
        el.setAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE, wasFocusable);
        el.removeAttribute(WAS_FOCUSABLE_ATTRIBUTE);
      } else {
        el.removeAttribute(_accessibility.IS_FOCUSABLE_ATTRIBUTE);
      }

      return true;
    }
    /**
     * Checks if `item` overflows a `container`.
     * TODO: check and fix all margin combination
     */

  }, {
    key: "isItemOverflowing",
    value: function isItemOverflowing(itemBoundingRect, containerBoundingRect) {
      return itemBoundingRect.right > containerBoundingRect.right || itemBoundingRect.left < containerBoundingRect.left;
    }
    /**
     * Checks if `item` would collide with eventual position of `overflowItem`.
     */

  }, {
    key: "wouldItemCollide",
    value: function wouldItemCollide($item, itemBoundingRect, overflowItemBoundingRect, containerBoundingRect) {
      var actualWindow = this.context.target.defaultView;
      var wouldCollide;

      if (this.rtl) {
        var itemLeftMargin = parseFloat(actualWindow.getComputedStyle($item).marginLeft) || 0;
        wouldCollide = itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin < containerBoundingRect.left; // console.log('Collision [RTL]', {
        //   wouldCollide,
        //   'itemBoundingRect.left': itemBoundingRect.left,
        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
        //   itemRightMargin: itemLeftMargin,
        //   sum: itemBoundingRect.left - overflowItemBoundingRect.width - itemLeftMargin,
        //   'overflowContainerBoundingRect.left': containerBoundingRect.left,
        // })
      } else {
        var itemRightMargin = parseFloat(actualWindow.getComputedStyle($item).marginRight) || 0;
        wouldCollide = itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin > containerBoundingRect.right; // console.log('Collision', {
        //   wouldCollide,
        //   'itemBoundingRect.right': itemBoundingRect.right,
        //   'overflowItemBoundingRect.width': overflowItemBoundingRect.width,
        //   itemRightMargin,
        //   sum: itemBoundingRect.right + overflowItemBoundingRect.width + itemRightMargin,
        //   'overflowContainerBoundingRect.right': containerBoundingRect.right,
        // })
      }

      return wouldCollide;
    }
    /**
     * Positions overflowItem next to lastVisible item
     * TODO: consider overflowItem margin
     */

  }, {
    key: "setOverflowPosition",
    value: function setOverflowPosition($overflowItem, $lastVisibleItem, lastVisibleItemRect, containerBoundingRect, absolutePositioningOffset) {
      var actualWindow = this.context.target.defaultView;

      if ($lastVisibleItem) {
        if (this.rtl) {
          var lastVisibleItemMarginLeft = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginLeft) || 0;
          $overflowItem.style.right = "".concat(containerBoundingRect.right - lastVisibleItemRect.left + lastVisibleItemMarginLeft + absolutePositioningOffset.horizontal, "px");
        } else {
          var lastVisibleItemRightMargin = parseFloat(actualWindow.getComputedStyle($lastVisibleItem).marginRight) || 0;
          $overflowItem.style.left = "".concat(lastVisibleItemRect.right - containerBoundingRect.left + lastVisibleItemRightMargin + absolutePositioningOffset.horizontal, "px");
        }
      } else {
        // there is no last visible item -> position the overflow as the first item
        this.lastVisibleItemIndex = -1;

        if (this.rtl) {
          $overflowItem.style.right = "".concat(absolutePositioningOffset.horizontal, "px");
        } else {
          $overflowItem.style.left = "".concat(absolutePositioningOffset.horizontal, "px");
        }
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.afterComponentRendered();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.animationFrameId !== undefined) {
        this.context.target.defaultView.cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = undefined;
      }
    }
  }, {
    key: "afterComponentRendered",
    value: function afterComponentRendered() {
      var _this2 = this;

      var actualWindow = this.context.target.defaultView;

      if (this.animationFrameId !== undefined) {
        actualWindow.cancelAnimationFrame(this.animationFrameId);
      } // Heads up! There are cases (like opening a portal and rendering the Toolbar there immediately) when rAF is necessary


      this.animationFrameId = actualWindow.requestAnimationFrame(function () {
        _this2.hideOverflowItems();
      });
    }
  }, {
    key: "renderOverflowItem",
    value: function renderOverflowItem(overflowItem) {
      var _this3 = this;

      return React.createElement(_reactComponentRef.Ref, {
        innerRef: this.overflowItemRef
      }, _ToolbarItem.default.create(overflowItem, {
        defaultProps: function defaultProps() {
          return {
            icon: {
              name: 'more',
              outline: true
            }
          };
        },
        overrideProps: {
          menu: this.props.overflowOpen ? this.getOverflowItems() : [],
          menuOpen: this.props.overflowOpen,
          onMenuOpenChange: function onMenuOpenChange(e, _ref) {
            var menuOpen = _ref.menuOpen;
            (0, _invoke2.default)(_this3.props, 'onOverflowOpenChange', e, Object.assign({}, _this3.props, {
              overflowOpen: menuOpen
            }));
          }
        }
      }));
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var accessibility = _ref2.accessibility,
          ElementType = _ref2.ElementType,
          classes = _ref2.classes,
          styles = _ref2.styles,
          variables = _ref2.variables,
          unhandledProps = _ref2.unhandledProps,
          rtl = _ref2.rtl;
      var windowRef = (0, _reactComponentRef.toRefObject)(this.context.target.defaultView);
      this.rtl = rtl;
      var _this$props = this.props,
          children = _this$props.children,
          items = _this$props.items,
          overflow = _this$props.overflow,
          overflowItem = _this$props.overflowItem;

      if (!overflow) {
        return React.createElement(ElementType, (0, _extends2.default)({
          className: classes.root
        }, accessibility.attributes.root, unhandledProps), (0, _lib.childrenExist)(children) ? children : this.renderItems(items, variables));
      }

      return React.createElement(React.Fragment, null, React.createElement(ElementType, (0, _extends2.default)({
        className: classes.root
      }, accessibility.attributes.root, unhandledProps), React.createElement("div", {
        className: classes.overflowContainer,
        ref: this.overflowContainerRef
      }, (0, _lib.childrenExist)(children) ? children : this.renderItems(this.getVisibleItems(), variables), this.renderOverflowItem(overflowItem)), React.createElement("div", {
        className: classes.offsetMeasure,
        ref: this.offsetMeasureRef
      })), React.createElement(_reactComponentEventListener.EventListener, {
        listener: this.handleWindowResize,
        targetRef: windowRef,
        type: "resize"
      }));
    }
  }]);
  return Toolbar;
}(_lib.UIComponent);

(0, _defineProperty2.default)(Toolbar, "create", void 0);
(0, _defineProperty2.default)(Toolbar, "className", 'ui-toolbar');
(0, _defineProperty2.default)(Toolbar, "displayName", 'Toolbar');
(0, _defineProperty2.default)(Toolbar, "propTypes", Object.assign({}, _lib.commonPropTypes.createCommon(), {
  items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item', 'group', 'toggle', 'custom']),
  overflow: PropTypes.bool,
  overflowOpen: PropTypes.bool,
  overflowItem: customPropTypes.shorthandAllowingChildren,
  onOverflow: PropTypes.func,
  onOverflowOpenChange: PropTypes.func,
  getOverflowItems: PropTypes.func
}));
(0, _defineProperty2.default)(Toolbar, "defaultProps", {
  accessibility: _accessibility.toolbarBehavior,
  items: [],
  overflowItem: {}
});
(0, _defineProperty2.default)(Toolbar, "CustomItem", _ToolbarCustomItem.default);
(0, _defineProperty2.default)(Toolbar, "Divider", _ToolbarDivider.default);
(0, _defineProperty2.default)(Toolbar, "Item", _ToolbarItem.default);
(0, _defineProperty2.default)(Toolbar, "Menu", _ToolbarMenu.default);
(0, _defineProperty2.default)(Toolbar, "MenuDivider", _ToolbarMenuDivider.default);
(0, _defineProperty2.default)(Toolbar, "MenuItem", _ToolbarMenuItem.default);
(0, _defineProperty2.default)(Toolbar, "MenuRadioGroup", _ToolbarMenuRadioGroup.default);
(0, _defineProperty2.default)(Toolbar, "RadioGroup", _ToolbarRadioGroup.default);
Toolbar.create = (0, _lib.createShorthandFactory)({
  Component: Toolbar,
  mappedProp: 'content'
});
/**
 * A Toolbar is a container for grouping a set of controls, often action controls (e.g. buttons) or input controls (e.g. checkboxes).
 *
 * @accessibility
 *  * Implements [ARIA Toolbar](https://www.w3.org/TR/wai-aria-practices-1.1/#toolbar) design pattern.
 * @accessibilityIssues
 * [Issue 988424: VoiceOver narrates selected for button in toolbar](https://bugs.chromium.org/p/chromium/issues/detail?id=988424)
 */

var _default = (0, _types.withSafeTypeForAs)(Toolbar);

exports.default = _default;