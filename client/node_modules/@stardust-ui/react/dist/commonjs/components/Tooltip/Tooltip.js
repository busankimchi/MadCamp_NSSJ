"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _reactComponentRef = require("@stardust-ui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@stardust-ui/react-proptypes"));

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _lib = require("../../lib");

var _positioner = require("../../lib/positioner");

var _TooltipContent = _interopRequireDefault(require("./TooltipContent"));

var _accessibility = require("@stardust-ui/accessibility");

var _PortalInner = _interopRequireDefault(require("../Portal/PortalInner"));

/**
 * A Tooltip displays additional non-modal information on top of its target element.
 * Tooltip doesn't receive focus and cannot contain focusable elements.
 *
 * @accessibility
 * Implements [ARIA Tooltip](https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip) design pattern.
 */
var Tooltip =
/*#__PURE__*/
function (_AutoControlledCompon) {
  (0, _inherits2.default)(Tooltip, _AutoControlledCompon);

  function Tooltip() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Tooltip)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "pointerTargetRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "triggerRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "contentRef", React.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "closeTimeoutId", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "actionHandlers", {
      close: function close(e) {
        _this.setTooltipOpen(false, e);

        e.stopPropagation();
        e.preventDefault();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getContentProps", function (predefinedProps) {
      var contentHandlerProps = {};

      contentHandlerProps.onMouseEnter = function (e, contentProps) {
        _this.setTooltipOpen(true, e);

        (0, _invoke2.default)(predefinedProps, 'onMouseEnter', e, contentProps);
      };

      contentHandlerProps.onMouseLeave = function (e, contentProps) {
        _this.setTooltipOpen(false, e);

        (0, _invoke2.default)(predefinedProps, 'onMouseLeave', e, contentProps);
      };

      return contentHandlerProps;
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "shouldStayOpen", function (e) {
      return (0, _invoke2.default)(e, 'currentTarget.contains', e.relatedTarget) || (0, _invoke2.default)(_this.contentRef.current, 'contains', e.relatedTarget);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "renderPopperChildren", function (tooltipPositionClasses, rtl, accessibility, _ref) {
      var placement = _ref.placement;
      var _this$props = _this.props,
          content = _this$props.content,
          pointing = _this$props.pointing;
      var tooltipContentAttributes = Object.assign({}, rtl && {
        dir: 'rtl'
      }, accessibility.attributes.tooltip, accessibility.keyHandlers.tooltip, {
        className: tooltipPositionClasses
      }, _this.getContentProps());
      var tooltipContent = Tooltip.Content.create(content, {
        defaultProps: function defaultProps() {
          return Object.assign({}, tooltipContentAttributes, {
            open: _this.state.open,
            placement: placement,
            pointing: pointing,
            pointerRef: _this.pointerTargetRef
          });
        },
        overrideProps: _this.getContentProps
      });
      return React.createElement(_reactComponentRef.Ref, {
        innerRef: _this.contentRef
      }, tooltipContent);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "scheduleTooltipClose", function (e) {
      var mouseLeaveDelay = _this.props.mouseLeaveDelay;
      _this.closeTimeoutId = setTimeout(function () {
        _this.trySetOpen(false, e);
      }, mouseLeaveDelay);
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "close", function (e, onClose) {
      if (_this.state.open) {
        _this.trySetOpen(false, e);

        onClose && onClose();
        e.stopPropagation();
      }
    });
    return _this;
  }

  (0, _createClass2.default)(Tooltip, [{
    key: "getInitialAutoControlledState",
    value: function getInitialAutoControlledState() {
      return {
        open: false
      };
    }
  }, {
    key: "renderComponent",
    value: function renderComponent(_ref2) {
      var classes = _ref2.classes,
          rtl = _ref2.rtl,
          accessibility = _ref2.accessibility;
      var _this$props2 = this.props,
          mountNode = _this$props2.mountNode,
          children = _this$props2.children,
          trigger = _this$props2.trigger;
      var tooltipContent = this.renderTooltipContent(classes.content, rtl, accessibility);
      var triggerNode = (0, _lib.childrenExist)(children) ? children : trigger;
      var triggerElement = triggerNode && React.Children.only(triggerNode);
      var triggerProps = this.getTriggerProps(triggerElement);
      return React.createElement(React.Fragment, null, triggerElement && React.createElement(_reactComponentRef.Ref, {
        innerRef: this.triggerRef
      }, React.cloneElement(triggerElement, Object.assign({}, accessibility.attributes.trigger, triggerProps, (0, _lib.applyAccessibilityKeyHandlers)(accessibility.keyHandlers.trigger, triggerProps)))), React.createElement(_PortalInner.default, {
        mountNode: mountNode
      }, tooltipContent));
    }
  }, {
    key: "getTriggerProps",
    value: function getTriggerProps(triggerElement) {
      var _this2 = this;

      var triggerProps = {};

      triggerProps.onFocus = function (e) {
        if ((0, _lib.isFromKeyboard)()) {
          _this2.trySetOpen(true, e);
        }

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        _invoke2.default.apply(void 0, [triggerElement, 'props.onFocus', e].concat(args));
      };

      triggerProps.onBlur = function (e) {
        if (!_this2.shouldStayOpen(e)) {
          _this2.trySetOpen(false, e);
        }

        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }

        _invoke2.default.apply(void 0, [triggerElement, 'props.onBlur', e].concat(args));
      };

      triggerProps.onMouseEnter = function (e) {
        _this2.setTooltipOpen(true, e);

        (0, _lib.setWhatInputSource)('mouse');

        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseEnter', e].concat(args));
      };

      triggerProps.onMouseLeave = function (e) {
        _this2.setTooltipOpen(false, e);

        for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          args[_key5 - 1] = arguments[_key5];
        }

        _invoke2.default.apply(void 0, [triggerElement, 'props.onMouseLeave', e].concat(args));
      };

      return triggerProps;
    }
  }, {
    key: "renderTooltipContent",
    value: function renderTooltipContent(tooltipPositionClasses, rtl, accessibility) {
      var _this$props3 = this.props,
          align = _this$props3.align,
          position = _this$props3.position,
          target = _this$props3.target,
          offset = _this$props3.offset;
      var open = this.state.open;
      return React.createElement(_positioner.Popper, {
        pointerTargetRef: this.pointerTargetRef,
        align: align,
        offset: offset,
        position: position,
        enabled: open,
        rtl: rtl,
        targetRef: target ? (0, _reactComponentRef.toRefObject)(target) : this.triggerRef,
        children: this.renderPopperChildren.bind(this, tooltipPositionClasses, rtl, accessibility)
      });
    }
  }, {
    key: "trySetOpen",
    value: function trySetOpen(newValue, eventArgs) {
      this.setState({
        open: newValue
      });
      (0, _invoke2.default)(this.props, 'onOpenChange', eventArgs, Object.assign({}, this.props, {
        open: newValue
      }));
    }
  }, {
    key: "setTooltipOpen",
    value: function setTooltipOpen(newOpen, e) {
      clearTimeout(this.closeTimeoutId);
      newOpen ? this.trySetOpen(true, e) : this.scheduleTooltipClose(e);
    }
  }], [{
    key: "getAutoControlledStateFromProps",
    value: function getAutoControlledStateFromProps(props, state) {
      return {
        contentId: (0, _lib.getOrGenerateIdFromShorthand)('tooltip-content-', props.content, state.contentId)
      };
    }
  }]);
  return Tooltip;
}(_lib.AutoControlledComponent);

exports.default = Tooltip;
(0, _defineProperty2.default)(Tooltip, "displayName", 'Tooltip');
(0, _defineProperty2.default)(Tooltip, "className", 'ui-tooltip');
(0, _defineProperty2.default)(Tooltip, "slotClassNames", {
  content: "".concat(Tooltip.className, "__content")
});
(0, _defineProperty2.default)(Tooltip, "Content", _TooltipContent.default);
(0, _defineProperty2.default)(Tooltip, "propTypes", Object.assign({}, _lib.commonPropTypes.createCommon({
  animated: false,
  as: false,
  content: false
}), {
  align: PropTypes.oneOf(_positioner.ALIGNMENTS),
  defaultOpen: PropTypes.bool,
  inline: PropTypes.bool,
  mountNode: customPropTypes.domNode,
  mouseLeaveDelay: PropTypes.number,
  offset: PropTypes.string,
  open: PropTypes.bool,
  onOpenChange: PropTypes.func,
  pointing: PropTypes.bool,
  position: PropTypes.oneOf(_positioner.POSITIONS),
  target: customPropTypes.domNode,
  trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.element]),
  content: customPropTypes.shorthandAllowingChildren
}));
(0, _defineProperty2.default)(Tooltip, "defaultProps", {
  align: 'center',
  position: 'above',
  mouseLeaveDelay: 10,
  pointing: true,
  accessibility: _accessibility.tooltipBehavior
});
(0, _defineProperty2.default)(Tooltip, "autoControlledProps", ['open']);
(0, _defineProperty2.default)(Tooltip, "create", void 0);
Tooltip.create = (0, _lib.createShorthandFactory)({
  Component: Tooltip,
  mappedProp: 'content'
});